# MySQL 인덱스 심화 학습

## 목차
1. [디스크 읽기 방식](#1-디스크-읽기-방식)
2. [인덱스 구조와 원리 (B-Tree)](#2-인덱스-구조와-원리-b-tree)
3. [인덱스 스캔 방식](#3-인덱스-스캔-방식)
4. [인덱스 종류와 특성](#4-인덱스-종류와-특성)
5. [다중 컬럼 인덱스](#5-다중-컬럼-인덱스)
6. [MySQL 8.0 추가 기능](#6-mysql-80-추가-기능)
7. [기타 인덱스 알고리즘](#7-기타-인덱스-알고리즘)
8. [인덱스 설계 실무](#8-인덱스-설계-실무)

---

## 1. 디스크 읽기 방식

### 1.1 랜덤 I/O vs 순차 I/O

**디스크 읽기의 성능을 결정하는 핵심 개념**입니다.

#### 랜덤 I/O (Random I/O)

디스크의 **여러 위치를 건너뛰며 읽는 방식**입니다.<br>
디스크 헤드를 이동시키는 시간(Seek Time)이 대부분의 시간을 차지합니다.

```sql
-- 인덱스를 사용한 조회
SELECT * FROM users WHERE age = 25;
-- 인덱스에서 조건을 만족하는 레코드 위치를 찾고,
-- 해당 위치로 이동하여 데이터를 읽음 (랜덤 I/O)
```

#### 순차 I/O (Sequential I/O)

디스크의 **연속된 위치를 순서대로 읽는 방식**입니다.<br>
헤드 이동이 최소화되어 빠릅니다.

```sql
-- 풀 테이블 스캔
SELECT * FROM users;
-- 테이블의 처음부터 끝까지 순서대로 읽음 (순차 I/O)
```

#### 성능 비교

**핵심 원칙: 순차 I/O가 랜덤 I/O보다 훨씬 빠르다**

하지만 **인덱스를 사용하는 이유는 읽어야 할 레코드 수를 줄이기 때문**입니다.

**예시:**

```sql
-- 테이블: 1,000,000건
-- WHERE age = 25 조건을 만족하는 레코드: 100건

-- Case 1: 풀 테이블 스캔 (순차 I/O)
-- 1,000,000건 모두 읽음 → 느림

-- Case 2: 인덱스 사용 (랜덤 I/O)
-- 100건만 읽음 → 빠름
```

**결론:**
- 전체 데이터의 **20~25% 이상**을 읽어야 한다면 → 풀 테이블 스캔이 유리
- **20~25% 미만**을 읽는다면 → 인덱스 사용이 유리

### 1.2 HDD vs SSD와 인덱스 효율성

#### HDD (Hard Disk Drive)

**기계적 구조:**
- 플래터(Platter)가 회전
- 헤드(Head)가 물리적으로 이동
- 순차 I/O와 랜덤 I/O의 성능 차이가 **매우 큼**

**특성:**
- 랜덤 I/O 성능: 100~200 IOPS
- 순차 I/O 성능: 순차는 빠름
- 인덱스 효과: **매우 큼**

#### SSD (Solid State Drive)

**전자적 구조:**
- 플래시 메모리 사용
- 물리적 이동 없음
- 순차 I/O와 랜덤 I/O의 성능 차이가 **작음**

**특성:**
- 랜덤 I/O 성능: 수만~수십만 IOPS
- 순차 I/O 성능: 더 빠름
- 인덱스 효과: **여전히 유효** (읽는 양 자체를 줄이므로)

**중요:**<br>
SSD를 사용해도 **인덱스는 여전히 필수**입니다.<br>
읽어야 할 데이터의 양 자체를 줄이는 것이 핵심이기 때문입니다.

### 1.3 인덱스를 사용하는 근본적인 이유

**핵심: 디스크 I/O 횟수를 줄이는 것**

1. **읽어야 할 데이터 양 감소**
   - 전체 테이블이 아닌 필요한 레코드만 읽음
   - 디스크 I/O 횟수 최소화

2. **정렬 작업 생략**
   - 인덱스는 정렬된 상태 유지
   - ORDER BY 절 처리 시 별도 정렬 불필요

3. **그룹핑 작업 최적화**
   - GROUP BY 절 처리 시 임시 테이블 사용 감소
   - MIN/MAX 같은 집계 함수 빠른 처리

---

## 2. 인덱스 구조와 원리 (B-Tree)

### 2.1 B-Tree (Balanced Tree) 구조

**MySQL InnoDB의 기본 인덱스 구조**입니다.<br>
B-Tree는 **균형 잡힌 트리 구조**로, 모든 리프 노드가 같은 깊이를 유지합니다.

#### 구조

```
                    [루트 노드]
                   /     |     \
            [브랜치 노드] [브랜치 노드]
           /    |    \
    [리프 노드] [리프 노드] [리프 노드]
```

**각 노드는 디스크의 페이지(Page) 단위로 저장됩니다.**

### 2.2 페이지(Page) / 블록(Block)

**페이지는 디스크 읽기/쓰기의 최소 논리 단위**입니다.

**특징:**
- InnoDB의 기본 페이지 크기: **16KB**
- 한 번의 I/O로 최소 16KB를 읽음
- 1바이트만 필요해도 16KB 전체를 읽어야 함

**성능에 미치는 영향:**

```sql
-- 인덱스 키가 16바이트인 경우
-- 한 페이지에 약 1,000개의 키 저장 가능

-- 인덱스 키가 32바이트인 경우
-- 한 페이지에 약 500개의 키 저장 가능
-- → B-Tree 깊이 증가 → 성능 저하
```

### 2.3 루트(Root) / 브랜치(Branch) / 리프(Leaf) 노드

#### 루트 노드 (Root Node)

**B-Tree의 최상위 노드**입니다.<br>
검색 시 항상 루트 노드부터 시작합니다.

**특징:**
- 항상 메모리(버퍼 풀)에 캐싱됨
- 디스크 I/O 없이 접근 가능

#### 브랜치 노드 (Branch Node)

**루트와 리프를 연결하는 중간 노드**입니다.<br>
다음 노드로의 포인터만 가지고 있습니다.

**특징:**
- 인덱스 키와 자식 노드 포인터 보유
- 실제 데이터는 없음
- 검색 경로를 안내하는 역할

#### 리프 노드 (Leaf Node)

**실제 데이터를 가리키는 최하위 노드**입니다.

**특징:**
- 인덱스 키와 데이터 레코드 주소(또는 PK) 저장
- 정렬된 순서로 연결 (Double Linked List)
- 범위 검색 시 순차적으로 읽기 가능

**클러스터링 인덱스:**
- 리프 노드에 **모든 컬럼 데이터** 포함

**세컨더리 인덱스:**
- 리프 노드에 **PK 값**만 포함

### 2.4 B-Tree 검색 과정

**예시: `WHERE id = 100` 검색**

```
1. 루트 노드 읽기 (1번 I/O)
   → id=100은 50~150 범위 → 두 번째 브랜치로 이동

2. 브랜치 노드 읽기 (2번 I/O)
   → id=100은 75~125 범위 → 세 번째 리프로 이동

3. 리프 노드 읽기 (3번 I/O)
   → id=100 찾음 → 데이터 레코드 주소 반환

4. 데이터 페이지 읽기 (4번 I/O)
   → 실제 레코드 반환
```

**총 4번의 디스크 I/O**<br>
풀 테이블 스캔이 수만~수백만 I/O인 것에 비하면 매우 적습니다.

### 2.5 인덱스 키 크기와 성능의 관계

**핵심 원칙: 인덱스 키는 작을수록 좋다**

#### 키 크기가 커지면 발생하는 문제

**1) 페이지 당 저장 개수 감소**

```sql
-- 페이지 크기: 16KB = 16,384바이트
-- 오버헤드(포인터 등): 약 150바이트

-- 인덱스 키 16바이트:
-- (16,384 - 150) / (16 + 12) ≈ 580개

-- 인덱스 키 32바이트:
-- (16,384 - 150) / (32 + 12) ≈ 369개
```

**2) B-Tree 깊이 증가**

```
인덱스 키 16바이트 (580개/페이지):
- 1레벨: 580개
- 2레벨: 580 × 580 = 336,400개
- 3레벨: 580³ ≈ 1억 9천만 개

인덱스 키 32바이트 (369개/페이지):
- 1레벨: 369개
- 2레벨: 369 × 369 = 136,161개
- 3레벨: 369³ ≈ 5천만 개

→ 같은 깊이에서 저장 가능한 레코드 수 감소
→ 더 많은 I/O 필요
```

**3) 버퍼 풀 효율 저하**

인덱스 키가 커지면 같은 메모리에 캐싱할 수 있는 키 개수가 줄어듭니다.

#### Bad Case: 불필요하게 큰 인덱스 키

```sql
-- ❌ 잘못된 예시
CREATE INDEX idx_user_info ON users (
    email,           -- 100바이트
    phone,           -- 20바이트
    address,         -- 200바이트
    created_at       -- 8바이트
);
-- 총 328바이트 → 페이지 당 약 49개만 저장

-- 페이지 수 증가 → I/O 증가 → 성능 저하
```

#### Good Case: 필요한 컬럼만 포함

```sql
-- ✅ 올바른 예시
CREATE INDEX idx_email ON users (email);  -- 100바이트

CREATE INDEX idx_created ON users (created_at);  -- 8바이트

-- 쿼리에 맞는 최소한의 인덱스만 생성
```

### 2.6 기수성(Cardinality) / 선택도(Selectivity)

**인덱스 효율의 핵심 지표**입니다.

#### 기수성 (Cardinality)

**컬럼에 저장된 값의 중복도**를 나타냅니다.<br>
고유한 값의 개수가 많을수록 **카디널리티가 높다**고 표현합니다.

**예시:**

```sql
-- users 테이블: 1,000,000건

-- id 컬럼 (PRIMARY KEY)
-- 고유값: 1,000,000개 → 카디널리티 매우 높음

-- gender 컬럼
-- 고유값: 2개 (M, F) → 카디널리티 매우 낮음

-- city 컬럼
-- 고유값: 100개 → 카디널리티 보통

-- email 컬럼 (UNIQUE)
-- 고유값: 1,000,000개 → 카디널리티 매우 높음
```

#### 선택도 (Selectivity)

**전체 레코드 중 조건을 만족하는 레코드의 비율**입니다.<br>
선택도가 낮을수록(5~10% 미만) 인덱스 효과가 큽니다.

**계산 공식:**

```
선택도 = (조건을 만족하는 레코드 수 / 전체 레코드 수) × 100
```

**예시:**

```sql
-- 전체 레코드: 1,000,000건

-- WHERE id = 100
-- 결과: 1건 → 선택도 0.0001% → 인덱스 매우 효과적

-- WHERE gender = 'M'
-- 결과: 500,000건 → 선택도 50% → 인덱스 비효율적

-- WHERE city = 'Seoul'
-- 결과: 100,000건 → 선택도 10% → 인덱스 보통
```

#### 인덱스 생성 판단 기준

**Good Case: 인덱스 생성 권장**

```sql
-- 카디널리티 높음 + 선택도 낮음
CREATE INDEX idx_email ON users (email);
-- 고유값 많음 + 조회 시 소수 레코드 반환

CREATE INDEX idx_phone ON users (phone);
-- 고유값 많음 + 조회 시 소수 레코드 반환
```

**Bad Case: 인덱스 비효율적**

```sql
-- ❌ 카디널리티 낮음
CREATE INDEX idx_gender ON users (gender);
-- 고유값 2개 (M, F)
-- WHERE gender = 'M' → 전체의 50% 읽음 → 풀 스캔이 나음

-- ❌ 카디널리티 낮음
CREATE INDEX idx_is_active ON users (is_active);
-- 고유값 2개 (true, false)
-- 인덱스 의미 없음
```

**예외 상황: 데이터 분포가 불균형한 경우**

```sql
-- is_deleted 컬럼
-- true: 100건 (0.01%)
-- false: 999,900건 (99.99%)

-- 이 경우 인덱스 생성 가능
CREATE INDEX idx_deleted ON users (is_deleted);

-- WHERE is_deleted = true
-- → 100건만 읽음 → 인덱스 효과적
```

---

## 3. 인덱스 스캔 방식

### 3.1 인덱스 레인지 스캔 (Index Range Scan)

**가장 일반적이고 효율적인 인덱스 스캔 방식**입니다.<br>
인덱스에서 **특정 범위의 레코드**를 읽습니다.

#### 동작 과정

```sql
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
```

**1) 인덱스 탐색 (Index Seek)**
- B-Tree를 타고 내려가 시작 지점(age=20) 찾기
- 루트 → 브랜치 → 리프 노드 순회

**2) 인덱스 스캔 (Index Scan)**
- 리프 노드를 순차적으로 읽으며 age=30까지 스캔
- 리프 노드는 Double Linked List로 연결됨

**3) 데이터 레코드 읽기**
- 각 인덱스 키에서 가리키는 실제 레코드 읽기
- 랜덤 I/O 발생

#### 실행 계획

```sql
EXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;

+------+-------+----------+------+
| type | key   | key_len  | rows |
+------+-------+----------+------+
| range| idx_age | 4      | 1000 |
+------+-------+----------+------+
```

**type: `range`** → 레인지 스캔 사용

#### 레인지 스캔이 사용되는 경우

```sql
-- 1. 범위 조건
WHERE age BETWEEN 20 AND 30
WHERE age >= 20
WHERE age > 20 AND age < 30

-- 2. IN 절
WHERE age IN (20, 25, 30)

-- 3. LIKE (와일드카드가 뒤에)
WHERE name LIKE 'Kim%'

-- 4. 부등호
WHERE created_at > '2023-01-01'
```

### 3.2 인덱스 풀 스캔 (Index Full Scan)

**인덱스의 처음부터 끝까지 모두 읽는 방식**입니다.<br>
테이블 풀 스캔보다는 빠르지만, 레인지 스캔보다는 느립니다.

#### 발생 조건

```sql
-- 쿼리: 인덱스에 포함된 컬럼만 SELECT
-- 인덱스: idx_age_name (age, name)

SELECT age, name FROM users WHERE name LIKE '%Kim%';
```

**특징:**
- WHERE 절이 인덱스 첫 번째 컬럼을 사용하지 않음
- 하지만 SELECT 절이 인덱스에 포함된 컬럼만 사용
- 테이블 접근 없이 인덱스만 읽음 → 빠름

#### 실행 계획

```sql
EXPLAIN SELECT age, name FROM users WHERE name LIKE '%Kim%';

+-------+--------------+----------+------+
| type  | key          | key_len  | rows |
+-------+--------------+----------+------+
| index | idx_age_name | 108      | All  |
+-------+--------------+----------+------+
```

**type: `index`** → 인덱스 풀 스캔

#### 언제 사용되는가?

**1) 커버링 인덱스 + 조건 없음**

```sql
-- 인덱스: idx_created (created_at)
SELECT created_at FROM users;
-- 테이블 접근 없이 인덱스만 읽음
```

**2) 정렬 조건이 인덱스와 일치**

```sql
-- 인덱스: idx_age (age)
SELECT * FROM users ORDER BY age;
-- 정렬 작업 생략 가능
```

### 3.3 루스 인덱스 스캔 (Loose Index Scan)

**인덱스를 띄엄띄엄 읽는 최적화 기법**입니다.<br>
GROUP BY나 MIN/MAX 쿼리에서 사용됩니다.

#### 동작 방식

```sql
-- 인덱스: idx_dept_salary (dept_id, salary)

SELECT dept_id, MIN(salary)
FROM employees
GROUP BY dept_id;
```

**일반 스캔 (타이트 인덱스 스캔):**
- 모든 레코드를 읽고 그룹핑 → 느림

**루스 인덱스 스캔:**
- 각 dept_id의 첫 번째 레코드만 읽음 → 빠름
- dept_id가 변경되는 지점만 찾아서 점프

**예시:**

```
인덱스 데이터:
(1, 3000) ← 읽음
(1, 3500)
(1, 4000)
(2, 2500) ← 읽음 (dept_id 변경)
(2, 3000)
(3, 3500) ← 읽음 (dept_id 변경)

→ 3개만 읽고 MIN 값 획득
```

#### 실행 계획

```sql
EXPLAIN SELECT dept_id, MIN(salary)
FROM employees
GROUP BY dept_id;

+------+----------------+-----------------+
| type | Extra          | key             |
+------+----------------+-----------------+
| range| Using index for group-by | idx_dept_salary |
+------+----------------+-----------------+
```

**Extra: `Using index for group-by`** → 루스 인덱스 스캔

#### 사용 조건

**1) GROUP BY 절이 인덱스 선두 컬럼**

```sql
-- ✅ Good
-- 인덱스: idx_dept_salary (dept_id, salary)
SELECT dept_id, MIN(salary)
FROM employees
GROUP BY dept_id;

-- ❌ Bad
-- 인덱스: idx_dept_salary (dept_id, salary)
SELECT dept_id, MIN(salary)
FROM employees
GROUP BY salary;  -- 인덱스 선두 컬럼이 아님
```

**2) MIN/MAX만 사용**

```sql
-- ✅ Good
SELECT dept_id, MIN(salary), MAX(salary)
FROM employees
GROUP BY dept_id;

-- ❌ Bad
SELECT dept_id, AVG(salary)
FROM employees
GROUP BY dept_id;  -- AVG는 모든 레코드 필요
```

### 3.4 인덱스 스킵 스캔 (Index Skip Scan)

**MySQL 8.0에서 추가된 신기능**입니다.<br>
복합 인덱스의 첫 번째 컬럼을 건너뛰고도 인덱스를 사용할 수 있습니다.

#### 기존 문제

```sql
-- 인덱스: idx_gender_age (gender, age)

-- Good: 첫 번째 컬럼 사용
SELECT * FROM users WHERE gender = 'M' AND age = 30;
-- 인덱스 사용 가능

-- Bad: 두 번째 컬럼만 사용
SELECT * FROM users WHERE age = 30;
-- 기존에는 인덱스 사용 불가 → 풀 테이블 스캔
```

#### 스킵 스캔 동작

**MySQL 8.0부터는 첫 번째 컬럼을 건너뛰어도 인덱스 사용 가능합니다.**

```sql
-- 내부적으로 다음과 같이 변환:
SELECT * FROM users WHERE gender = 'M' AND age = 30
UNION ALL
SELECT * FROM users WHERE gender = 'F' AND age = 30;

-- gender의 카디널리티가 낮으면 (예: M, F 두 개)
-- 스킵 스캔이 효율적
```

#### 실행 계획

```sql
EXPLAIN SELECT * FROM users WHERE age = 30;

+------+---------------+-----------------+
| type | key           | Extra           |
+------+---------------+-----------------+
| range| idx_gender_age | Using index for skip scan |
+------+---------------+-----------------+
```

**Extra: `Using index for skip scan`** → 스킵 스캔 사용

#### 사용 조건

**1) 첫 번째 컬럼의 카디널리티가 낮아야 함**

```sql
-- ✅ Good: gender는 M, F 두 개만
-- 인덱스: idx_gender_age (gender, age)
SELECT * FROM users WHERE age = 30;
-- 스킵 스캔 효율적

-- ❌ Bad: email은 고유값 많음
-- 인덱스: idx_email_age (email, age)
SELECT * FROM users WHERE age = 30;
-- 스킵 스캔 비효율적 (풀 스캔이 나음)
```

**2) 두 번째 컬럼의 선택도가 높아야 함**

```sql
-- WHERE age = 30 → 소수의 레코드만 반환
-- 스킵 스캔 효과적
```

#### 주의사항

**스킵 스캔은 만능이 아닙니다.**<br>
첫 번째 컬럼의 고유값이 많으면 오히려 성능 저하가 발생합니다.

**권장:**
- 인덱스 설계 시 컬럼 순서를 올바르게 정하는 것이 우선
- 스킵 스캔은 보조적인 최적화 기법

---

## 4. 인덱스 종류와 특성

### 4.1 클러스터링 인덱스 (Clustered Index)

**테이블 데이터의 물리적 저장 순서를 결정하는 인덱스**입니다.<br>
InnoDB에서는 **PRIMARY KEY가 클러스터링 인덱스**입니다.

#### 특징

**1) 테이블 당 1개만 존재**

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,      -- 클러스터링 인덱스
    email VARCHAR(100) UNIQUE,
    name VARCHAR(50)
);
```

**2) 리프 노드에 모든 데이터 포함**

```
일반 인덱스 리프 노드:
[인덱스 키] → [레코드 주소] → 데이터 페이지 읽기

클러스터링 인덱스 리프 노드:
[인덱스 키] → [모든 컬럼 데이터] → 바로 사용 가능
```

**3) PK 순서로 물리적 정렬**

```sql
INSERT INTO users (id, name) VALUES (3, 'C');
INSERT INTO users (id, name) VALUES (1, 'A');
INSERT INTO users (id, name) VALUES (2, 'B');

-- 디스크 저장 순서:
-- id=1 (A)
-- id=2 (B)
-- id=3 (C)
-- → PK 순서로 정렬됨
```

#### 장점

**1) PK 검색 시 매우 빠름**

```sql
SELECT * FROM users WHERE id = 100;
-- 인덱스 탐색 → 바로 모든 데이터 반환
-- 추가 I/O 불필요
```

**2) PK 범위 검색 시 순차 I/O**

```sql
SELECT * FROM users WHERE id BETWEEN 100 AND 200;
-- 리프 노드가 물리적으로 연속됨
-- 순차 I/O → 빠름
```

**3) ORDER BY PK 시 정렬 생략**

```sql
SELECT * FROM users ORDER BY id;
-- 이미 정렬되어 있음
-- filesort 없음 → 빠름
```

#### 단점

**1) 데이터 삽입 시 페이지 분할 발생**

```sql
-- PK가 순차적이지 않으면:
INSERT INTO users (id, name) VALUES (150, 'New');
-- id=100~200 페이지가 가득 찼다면
-- 페이지 분할(Page Split) 발생 → 느림
```

**2) PK 크기가 클수록 성능 저하**

```sql
-- ❌ Bad: PK가 큼
CREATE TABLE orders (
    order_id VARCHAR(100) PRIMARY KEY,  -- 100바이트
    ...
);
-- 세컨더리 인덱스가 모두 100바이트 PK를 포함
-- 모든 인덱스 크기 증가

-- ✅ Good: PK가 작음
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 8바이트
    order_id VARCHAR(100) UNIQUE,
    ...
);
```

**3) 세컨더리 인덱스 성능에 영향**

세컨더리 인덱스의 리프 노드는 PK를 가리킵니다.<br>
PK가 크면 세컨더리 인덱스도 커집니다.

#### PK 설계 원칙

**1) AUTO_INCREMENT 사용 권장**

```sql
-- ✅ Good
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    ...
);
-- 순차적 증가 → 페이지 분할 최소화
```

**2) 작은 크기 사용**

```sql
-- ❌ Bad
CREATE TABLE orders (
    order_id CHAR(36) PRIMARY KEY,  -- UUID: 36바이트
    ...
);

-- ✅ Good
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 8바이트
    order_id CHAR(36) UNIQUE,
    ...
);
```

**3) 변경되지 않는 값 사용**

```sql
-- ❌ Bad: 변경 가능한 값
CREATE TABLE users (
    email VARCHAR(100) PRIMARY KEY,
    ...
);
-- 이메일 변경 시 모든 세컨더리 인덱스도 업데이트

-- ✅ Good: 변경 불가능한 값
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    ...
);
```

### 4.2 세컨더리 인덱스 (Secondary Index)

**클러스터링 인덱스가 아닌 모든 인덱스**를 의미합니다.

#### 특징

**1) 리프 노드에 PK 값 포함**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,           -- 클러스터링 인덱스
    email VARCHAR(100),
    INDEX idx_email (email)          -- 세컨더리 인덱스
);
```

**세컨더리 인덱스 구조:**

```
[email 인덱스]
리프 노드: [email, PK(id)]

검색 과정:
1. email 인덱스 탐색
2. PK 값 획득
3. 클러스터링 인덱스 탐색
4. 전체 데이터 반환
```

**2) PK 검색 추가 필요**

```sql
SELECT * FROM users WHERE email = 'test@example.com';

-- 내부 동작:
-- 1. idx_email에서 email = 'test@example.com' 찾기
-- 2. PK(id) 획득 (예: id=100)
-- 3. PRIMARY KEY에서 id=100 찾기
-- 4. 모든 컬럼 반환
```

#### 장점

**1) 여러 개 생성 가능**

```sql
CREATE INDEX idx_email ON users (email);
CREATE INDEX idx_name ON users (name);
CREATE INDEX idx_created ON users (created_at);
-- 테이블 당 제한 없음 (실무에서는 5~10개 권장)
```

**2) 다양한 검색 조건 지원**

```sql
SELECT * FROM users WHERE email = 'test@example.com';
SELECT * FROM users WHERE name = 'Kim';
SELECT * FROM users WHERE created_at > '2023-01-01';
-- 각 조건에 맞는 인덱스 사용
```

#### 단점

**1) PK 검색 오버헤드**

클러스터링 인덱스보다 느립니다. (PK 검색 추가)

**2) PK 크기에 영향받음**

```sql
-- PK가 크면 모든 세컨더리 인덱스도 커짐
CREATE TABLE orders (
    order_id VARCHAR(100) PRIMARY KEY,  -- 100바이트
    user_id BIGINT,
    INDEX idx_user (user_id)
);

-- idx_user 리프 노드: [user_id(8바이트), order_id(100바이트)]
-- → 불필요하게 큼
```

### 4.3 유니크 인덱스 vs 일반 인덱스

#### 유니크 인덱스 (Unique Index)

**중복 값을 허용하지 않는 인덱스**입니다.

```sql
CREATE UNIQUE INDEX idx_email ON users (email);
-- 또는
ALTER TABLE users ADD UNIQUE KEY (email);
```

#### 읽기 성능 차이

**거의 없습니다.**

```sql
-- 유니크 인덱스
SELECT * FROM users WHERE email = 'test@example.com';
-- 1건 찾으면 검색 중단

-- 일반 인덱스
SELECT * FROM users WHERE email = 'test@example.com';
-- 1건 찾아도 중복 확인을 위해 다음 레코드 확인
-- → 미미한 차이
```

**실행 계획:**

```sql
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 유니크 인덱스
+------+-------+
| type | rows  |
+------+-------+
| const|   1   |  -- 정확히 1건
+------+-------+

-- 일반 인덱스
+------+-------+
| type | rows  |
+------+-------+
| ref  |   1   |  -- 1건 추정
+------+-------+
```

#### 쓰기 성능 차이

**유니크 인덱스가 느립니다.**

**1) 중복 체크 오버헤드**

```sql
INSERT INTO users (email, name) VALUES ('test@example.com', 'Kim');

-- 유니크 인덱스:
-- 1. email='test@example.com' 중복 체크 (인덱스 검색)
-- 2. 중복 없으면 삽입
-- 3. 중복 있으면 에러

-- 일반 인덱스:
-- 바로 삽입
```

**2) 체인지 버퍼 사용 불가**

```sql
-- 일반 인덱스:
-- 체인지 버퍼에 변경사항 모아두고 나중에 일괄 반영
-- → 빠름

-- 유니크 인덱스:
-- 중복 체크를 위해 즉시 인덱스 페이지 읽기
-- 체인지 버퍼 사용 불가
-- → 느림
```

#### 사용 원칙

**1) 비즈니스 제약이 있으면 유니크 인덱스 사용**

```sql
-- ✅ Good
CREATE UNIQUE INDEX idx_email ON users (email);
-- 이메일 중복 방지 필요 → 유니크 인덱스 필수
```

**2) 단순 성능 목적이면 일반 인덱스 사용**

```sql
-- ✅ Good
CREATE INDEX idx_created ON users (created_at);
-- 검색 성능만 필요 → 일반 인덱스
```

**3) NULL 처리**

```sql
-- 유니크 인덱스는 NULL 허용
CREATE UNIQUE INDEX idx_phone ON users (phone);

INSERT INTO users (phone) VALUES (NULL);  -- OK
INSERT INTO users (phone) VALUES (NULL);  -- OK (NULL은 중복 가능)
INSERT INTO users (phone) VALUES ('010-1234-5678');  -- OK
INSERT INTO users (phone) VALUES ('010-1234-5678');  -- Error (중복)
```

### 4.4 외래키(FK)와 잠금 전파

**외래키는 데이터 무결성을 보장하지만, 잠금 전파를 일으킵니다.**

#### 기본 동작

```sql
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(id)
);
```

#### 잠금 전파 시나리오

```sql
-- Transaction 1
START TRANSACTION;
INSERT INTO employees (id, name, dept_id) VALUES (1, 'Kim', 10);
-- employees 레코드: 배타 락
-- departments.id=10: 공유 락 (FK 체크)

-- Transaction 2
DELETE FROM departments WHERE id = 10;
-- 대기 발생! (공유 락 해제 대기)
```

**문제점:**
- 자식 테이블 INSERT 시 부모 테이블 잠금
- 부모 테이블 UPDATE/DELETE 시 대기 발생
- 데드락 위험 증가

#### 실무 선택

**1) 외래키 제거 (권장)**

```sql
-- FK 제거
ALTER TABLE employees DROP FOREIGN KEY fk_dept_id;

-- 애플리케이션 레벨에서 검증
if (!departmentRepository.existsById(deptId)) {
    throw new InvalidDepartmentException("존재하지 않는 부서입니다");
}
```

**장점:**
- 잠금 전파 없음
- 성능 향상
- 유연한 비즈니스 로직

**단점:**
- 애플리케이션에서 직접 검증 필요
- 데이터 정합성 보장이 약함

**2) 외래키 유지**

```sql
-- FK 유지
FOREIGN KEY (dept_id) REFERENCES departments(id)
```

**장점:**
- DB 레벨 데이터 무결성 보장
- 실수 방지

**단점:**
- 성능 저하
- 잠금 전파
- 데드락 위험

**실무 권장:**
- 대용량 서비스: 외래키 제거
- 소규모 서비스: 외래키 유지
- 금융/결제 시스템: 외래키 유지 + 트랜잭션 설계 주의

---

## 5. 다중 컬럼 인덱스

### 5.1 복합 인덱스 (Composite Index)

**두 개 이상의 컬럼을 조합한 인덱스**입니다.

```sql
CREATE INDEX idx_name_age ON users (name, age);
```

#### 인덱스 저장 구조

```
[name='Kim', age=20]
[name='Kim', age=25]
[name='Kim', age=30]
[name='Lee', age=20]
[name='Lee', age=25]
[name='Park', age=20]

→ name 기준 정렬, 같은 name 내에서 age 정렬
```

### 5.2 컬럼 순서의 중요성

**인덱스 컬럼 순서는 성능에 결정적인 영향을 미칩니다.**

#### 인덱스 사용 규칙

**왼쪽 컬럼부터 순서대로 사용해야 합니다.**

```sql
-- 인덱스: idx_name_age (name, age)

-- ✅ 인덱스 사용 O
SELECT * FROM users WHERE name = 'Kim' AND age = 30;
-- name, age 모두 사용

-- ✅ 인덱스 사용 O
SELECT * FROM users WHERE name = 'Kim';
-- name만 사용 (선두 컬럼)

-- ❌ 인덱스 사용 X
SELECT * FROM users WHERE age = 30;
-- age만 사용 (선두 컬럼 없음)
-- MySQL 8.0에서는 스킵 스캔으로 사용 가능할 수도 있음
```

#### 컬럼 순서 결정 원칙

**1) 등호(=) 조건 우선**

```sql
-- 쿼리
SELECT * FROM users
WHERE status = 'ACTIVE'  -- 등호
  AND created_at > '2023-01-01';  -- 범위

-- ✅ Good
CREATE INDEX idx_status_created (status, created_at);
-- 등호 조건(status)을 선두에

-- ❌ Bad
CREATE INDEX idx_created_status (created_at, status);
-- 범위 조건(created_at)을 선두에 → 비효율
```

**이유:**
- 등호 조건은 범위를 정확히 좁힘
- 범위 조건은 그 이후 컬럼 사용 불가

**2) 카디널리티 높은 컬럼 우선**

```sql
-- users 테이블
-- email: 고유값 1,000,000개 (카디널리티 높음)
-- gender: 고유값 2개 (카디널리티 낮음)

-- ✅ Good
CREATE INDEX idx_email_gender (email, gender);
-- 카디널리티 높은 email 선두

-- ❌ Bad
CREATE INDEX idx_gender_email (gender, email);
-- 카디널리티 낮은 gender 선두
```

**이유:**
- 카디널리티 높은 컬럼이 범위를 더 좁힘
- 검색 효율 증가

**3) 자주 사용되는 조건 우선**

```sql
-- 쿼리 1 (90% 사용):
-- WHERE status = 'ACTIVE'

-- 쿼리 2 (10% 사용):
-- WHERE status = 'ACTIVE' AND city = 'Seoul'

-- ✅ Good
CREATE INDEX idx_status_city (status, city);
-- 두 쿼리 모두 지원 (쿼리 1은 status만 사용)
```

### 5.3 복합 인덱스 예시

#### Bad Case: 잘못된 순서

```sql
-- 인덱스: idx_age_name (age, name)

-- 쿼리
SELECT * FROM users
WHERE name = 'Kim'  -- 두 번째 컬럼
  AND age BETWEEN 20 AND 30;  -- 첫 번째 컬럼

-- 실행 계획:
-- type: ALL (풀 테이블 스캔)
-- 인덱스 사용 불가 (선두 컬럼 age가 범위 조건)
```

#### Good Case: 올바른 순서

```sql
-- 인덱스: idx_name_age (name, age)

-- 쿼리
SELECT * FROM users
WHERE name = 'Kim'  -- 첫 번째 컬럼 (등호)
  AND age BETWEEN 20 AND 30;  -- 두 번째 컬럼 (범위)

-- 실행 계획:
-- type: range
-- 인덱스 완벽히 사용
```

#### 범위 조건 뒤 컬럼 사용 불가

```sql
-- 인덱스: idx_created_status_city (created_at, status, city)

-- 쿼리
SELECT * FROM users
WHERE created_at > '2023-01-01'  -- 범위 조건
  AND status = 'ACTIVE'
  AND city = 'Seoul';

-- 실제 사용:
-- created_at만 인덱스 사용
-- status, city는 인덱스 사용 불가 (범위 조건 뒤)

-- ✅ 개선:
CREATE INDEX idx_status_city_created (status, city, created_at);
-- 등호 조건(status, city)을 선두에
-- 범위 조건(created_at)을 마지막에
```

### 5.4 커버링 인덱스 (Covering Index)

**쿼리에 필요한 모든 컬럼이 인덱스에 포함된 경우**를 의미합니다.<br>
**성능 튜닝의 치트키**입니다.

#### 일반 쿼리 vs 커버링 인덱스

**일반 쿼리:**

```sql
-- 인덱스: idx_name (name)

SELECT id, name, age, email
FROM users
WHERE name = 'Kim';

-- 동작:
-- 1. idx_name에서 name='Kim' 찾기
-- 2. PK 획득
-- 3. 클러스터링 인덱스에서 전체 데이터 읽기 (랜덤 I/O)
```

**커버링 인덱스:**

```sql
-- 인덱스: idx_name_age_email (name, age, email)

SELECT id, name, age, email
FROM users
WHERE name = 'Kim';

-- 동작:
-- 1. idx_name_age_email에서 name='Kim' 찾기
-- 2. 인덱스에 age, email 포함됨
-- 3. PK는 세컨더리 인덱스에 자동 포함
-- 4. 테이블 접근 불필요! (인덱스만 읽음)
```

#### 실행 계획

```sql
EXPLAIN SELECT id, name, age, email
FROM users
WHERE name = 'Kim';

+---------+-------------------+
| type    | Extra             |
+---------+-------------------+
| ref     | Using index       |
+---------+-------------------+
```

**Extra: `Using index`** → 커버링 인덱스 사용

#### 성능 향상

**1) 테이블 접근 없음**

```sql
-- 일반:
-- 인덱스 읽기 + 테이블 읽기 (랜덤 I/O)

-- 커버링 인덱스:
-- 인덱스 읽기만 (순차 I/O)
```

**2) I/O 횟수 대폭 감소**

```sql
-- 100건 조회 시:

-- 일반:
-- 인덱스 I/O: 3~4회
-- 테이블 I/O: 100회
-- 총: 103~104회

-- 커버링 인덱스:
-- 인덱스 I/O: 3~4회
-- 총: 3~4회
```

**성능 향상: 수십 배**

#### 커버링 인덱스 설계

**Bad Case: SELECT * 사용**

```sql
-- ❌ 커버링 인덱스 불가능
SELECT *
FROM users
WHERE name = 'Kim';

-- 모든 컬럼을 인덱스에 포함할 수 없음
-- (인덱스가 너무 커짐)
```

**Good Case: 필요한 컬럼만 SELECT**

```sql
-- ✅ 커버링 인덱스 가능
SELECT id, name, age
FROM users
WHERE name = 'Kim';

-- 인덱스: idx_name_age (name, age)
-- id는 자동 포함 (PK)
```

#### 실무 활용

**페이징 쿼리 최적화:**

```sql
-- ❌ Bad: 느림
SELECT *
FROM users
WHERE status = 'ACTIVE'
ORDER BY created_at DESC
LIMIT 100 OFFSET 10000;

-- 10,000건을 건너뛰고 100건 읽기
-- 10,100건의 테이블 접근 발생

-- ✅ Good: 빠름
SELECT id
FROM users
WHERE status = 'ACTIVE'
ORDER BY created_at DESC
LIMIT 100 OFFSET 10000;

-- 인덱스: idx_status_created (status, created_at)
-- 커버링 인덱스로 id만 빠르게 획득

-- 그 후 IN 절로 실제 데이터 조회:
SELECT *
FROM users
WHERE id IN (/* 위에서 획득한 100개의 id */);
```

**집계 쿼리 최적화:**

```sql
-- 인덱스: idx_status_created (status, created_at)

-- ✅ 빠름 (커버링 인덱스)
SELECT COUNT(*)
FROM users
WHERE status = 'ACTIVE'
  AND created_at > '2023-01-01';

-- 테이블 접근 없이 인덱스만 카운트
```

---

## 6. MySQL 8.0 추가 기능

### 6.1 내림차순 인덱스 (Descending Index)

**MySQL 8.0부터 진짜 내림차순 인덱스가 지원됩니다.**

#### 이전 버전 (MySQL 5.7)

```sql
-- 내림차순 지정해도 무시됨
CREATE INDEX idx_created ON users (created_at DESC);
-- 실제로는 ASC로 생성됨
-- DESC는 검색 시에만 역순으로 읽음
```

#### MySQL 8.0

```sql
-- 진짜 내림차순으로 저장됨
CREATE INDEX idx_created_desc ON users (created_at DESC);

-- 저장 순서:
-- 2024-01-01
-- 2023-12-31
-- 2023-12-30
-- ...
-- 2023-01-01
```

#### 활용 사례

**정렬 방향이 혼합된 쿼리:**

```sql
-- 쿼리: 최신순 정렬
SELECT * FROM posts
ORDER BY created_at DESC, id DESC
LIMIT 10;

-- ✅ Good (MySQL 8.0)
CREATE INDEX idx_created_id ON posts (created_at DESC, id DESC);
-- filesort 없음

-- ❌ Bad (MySQL 5.7)
CREATE INDEX idx_created_id ON posts (created_at, id);
-- 역순 읽기 또는 filesort 발생
```

**혼합 정렬:**

```sql
-- 쿼리
SELECT * FROM orders
ORDER BY status ASC, created_at DESC;

-- ✅ Good
CREATE INDEX idx_status_created ON orders (status ASC, created_at DESC);
-- 완벽히 일치 → filesort 없음
```

#### 실행 계획 확인

```sql
EXPLAIN SELECT * FROM posts
ORDER BY created_at DESC, id DESC
LIMIT 10;

+------+---------------------+
| type | Extra               |
+------+---------------------+
| index| Using index         |
+------+---------------------+

-- "Using filesort" 없음 → 정렬 작업 생략
```

### 6.2 함수 기반 인덱스 (Function-Based Index)

**함수나 표현식의 결과값에 대해 인덱스를 생성**할 수 있습니다.

#### 기존 문제

```sql
-- 쿼리: 소문자로 변환하여 검색
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- 문제:
-- LOWER(email) 함수 사용
-- → 인덱스 사용 불가
-- → 풀 테이블 스캔
```

#### MySQL 8.0 해결

```sql
-- 함수 기반 인덱스 생성
CREATE INDEX idx_email_lower ON users ((LOWER(email)));

-- 쿼리
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- 실행 계획:
-- type: ref
-- key: idx_email_lower
-- → 인덱스 사용!
```

#### 활용 사례

**1) 대소문자 구분 없는 검색**

```sql
CREATE INDEX idx_name_lower ON users ((LOWER(name)));

SELECT * FROM users WHERE LOWER(name) = 'kim';
-- 인덱스 사용
```

**2) JSON 필드 검색**

```sql
-- JSON 컬럼
ALTER TABLE products ADD COLUMN attrs JSON;

-- 함수 기반 인덱스
CREATE INDEX idx_brand ON products ((JSON_UNQUOTE(JSON_EXTRACT(attrs, '$.brand'))));

-- 쿼리
SELECT * FROM products
WHERE JSON_UNQUOTE(JSON_EXTRACT(attrs, '$.brand')) = 'Samsung';
-- 인덱스 사용
```

**3) 계산 필드**

```sql
-- 인덱스: 할인가
CREATE INDEX idx_discounted_price ON products (((price * (100 - discount_rate) / 100)));

-- 쿼리
SELECT * FROM products
WHERE (price * (100 - discount_rate) / 100) < 10000;
-- 인덱스 사용
```

#### 주의사항

**1) 표현식을 정확히 일치시켜야 함**

```sql
-- 인덱스
CREATE INDEX idx_email_lower ON users ((LOWER(email)));

-- ✅ 인덱스 사용
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- ❌ 인덱스 미사용
SELECT * FROM users WHERE UPPER(email) = 'TEST@EXAMPLE.COM';
-- UPPER는 인덱스와 다름
```

**2) 가상 컬럼 사용도 가능**

```sql
-- 가상 컬럼 생성
ALTER TABLE users
ADD COLUMN email_lower VARCHAR(100) AS (LOWER(email)) VIRTUAL;

-- 가상 컬럼에 인덱스
CREATE INDEX idx_email_lower ON users (email_lower);

-- 쿼리
SELECT * FROM users WHERE email_lower = 'test@example.com';
-- 인덱스 사용
```

### 6.3 가상 컬럼 (Virtual Column)

**다른 컬럼의 값으로 계산되는 컬럼**입니다.<br>
실제 저장되지 않고(VIRTUAL) 또는 저장되는(STORED) 두 가지 방식이 있습니다.

#### VIRTUAL vs STORED

**VIRTUAL:**

```sql
ALTER TABLE users
ADD COLUMN full_name VARCHAR(200) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL;

-- 특징:
-- 저장 안 됨 (디스크 공간 사용 X)
-- 조회 시마다 계산
-- 빠른 INSERT/UPDATE
```

**STORED:**

```sql
ALTER TABLE users
ADD COLUMN full_name VARCHAR(200) AS (CONCAT(first_name, ' ', last_name)) STORED;

-- 특징:
-- 디스크에 저장됨 (공간 사용 O)
-- 조회 시 계산 불필요
-- INSERT/UPDATE 시 계산하여 저장
```

#### 활용 사례

**1) 계산 필드 인덱스**

```sql
-- VIRTUAL 컬럼 + 인덱스
ALTER TABLE orders
ADD COLUMN total_price INT AS (quantity * unit_price) VIRTUAL;

CREATE INDEX idx_total_price ON orders (total_price);

-- 쿼리
SELECT * FROM orders WHERE total_price > 100000;
-- 인덱스 사용
```

**2) JSON 필드 검색**

```sql
-- JSON 컬럼
ALTER TABLE products ADD COLUMN attrs JSON;

-- VIRTUAL 컬럼
ALTER TABLE products
ADD COLUMN brand VARCHAR(50) AS (JSON_UNQUOTE(JSON_EXTRACT(attrs, '$.brand'))) VIRTUAL;

-- 인덱스
CREATE INDEX idx_brand ON products (brand);

-- 쿼리
SELECT * FROM products WHERE brand = 'Samsung';
-- 인덱스 사용
```

**3) 파티셔닝 키**

```sql
-- 날짜 추출
ALTER TABLE logs
ADD COLUMN log_year INT AS (YEAR(created_at)) STORED;

-- 파티셔닝
ALTER TABLE logs PARTITION BY RANGE (log_year) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);
```

#### VIRTUAL vs STORED 선택

| 구분 | VIRTUAL | STORED |
|------|---------|--------|
| 저장 공간 | 사용 안 함 | 사용 |
| 조회 성능 | 느림 (계산) | 빠름 |
| 쓰기 성능 | 빠름 | 느림 (계산) |
| 인덱스 | 가능 | 가능 |
| 권장 | 인덱스 + 읽기 많음 | 복잡한 계산 + 쓰기 많음 |

---

## 7. 기타 인덱스 알고리즘

### 7.1 R-Tree 인덱스

**공간 데이터(Spatial Data)를 위한 인덱스**입니다.<br>
GIS(Geographic Information System), 위치 기반 서비스에 사용됩니다.

#### 특징

**2차원 좌표를 효율적으로 검색**합니다.

```sql
CREATE TABLE places (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    location POINT NOT NULL,
    SPATIAL INDEX idx_location (location)
);

-- 데이터 삽입
INSERT INTO places (id, name, location)
VALUES (1, '강남역', ST_GeomFromText('POINT(37.497928 127.027621)'));
```

#### 공간 검색

**반경 검색:**

```sql
-- 현재 위치에서 반경 1km 이내 검색
SELECT name, ST_Distance_Sphere(location, ST_GeomFromText('POINT(37.5 127.0)')) AS distance
FROM places
WHERE ST_Distance_Sphere(location, ST_GeomFromText('POINT(37.5 127.0)')) < 1000
ORDER BY distance;

-- R-Tree 인덱스 사용
```

**영역 검색:**

```sql
-- 특정 사각형 영역 내 검색
SELECT name
FROM places
WHERE MBRContains(
    ST_GeomFromText('POLYGON((37.4 127.0, 37.6 127.0, 37.6 127.2, 37.4 127.2, 37.4 127.0))'),
    location
);
```

#### 활용 사례

- 배달 앱: 주변 음식점 검색
- 지도 앱: 주변 POI 검색
- 차량 공유: 가까운 차량 찾기

### 7.2 전문 검색 인덱스 (Full-text Index)

**텍스트의 내용을 검색하기 위한 인덱스**입니다.<br>
일반 LIKE 검색보다 훨씬 빠릅니다.

#### 생성

```sql
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT INDEX idx_content (title, content)
);
```

#### 검색

**자연어 검색:**

```sql
SELECT *
FROM articles
WHERE MATCH(title, content) AGAINST('MySQL 성능 최적화');

-- 자연어 모드 (기본)
-- 관련도 점수 계산
-- 검색어를 포함한 문서 반환
```

**불린 검색:**

```sql
-- AND 조건
SELECT *
FROM articles
WHERE MATCH(title, content) AGAINST('+MySQL +인덱스' IN BOOLEAN MODE);

-- OR 조건
SELECT *
FROM articles
WHERE MATCH(title, content) AGAINST('MySQL 인덱스' IN BOOLEAN MODE);

-- NOT 조건
SELECT *
FROM articles
WHERE MATCH(title, content) AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);

-- 구문 검색
SELECT *
FROM articles
WHERE MATCH(title, content) AGAINST('"Real MySQL"' IN BOOLEAN MODE);
```

#### 관련도 점수

```sql
SELECT title,
       MATCH(title, content) AGAINST('MySQL 인덱스') AS score
FROM articles
WHERE MATCH(title, content) AGAINST('MySQL 인덱스')
ORDER BY score DESC;

-- score가 높을수록 관련도 높음
```

### 7.3 역인덱스 (Inverted Index)

**전문 검색 인덱스의 내부 구조**입니다.

#### 구조

**일반 인덱스:**

```
[문서 ID] → [내용]
1 → "MySQL은 빠릅니다"
2 → "인덱스는 중요합니다"
3 → "MySQL 인덱스 최적화"
```

**역인덱스:**

```
[단어] → [문서 ID 리스트]
"MySQL" → [1, 3]
"인덱스" → [2, 3]
"빠릅니다" → [1]
"중요합니다" → [2]
"최적화" → [3]
```

**검색 과정:**

```sql
-- 쿼리: "MySQL 인덱스"

1. "MySQL" → [1, 3]
2. "인덱스" → [2, 3]
3. 교집합 또는 합집합 계산
   - AND: [3]
   - OR: [1, 2, 3]
```

### 7.4 n-gram 파서

**문자열을 n개씩 쪼개어 인덱싱하는 방식**입니다.<br>
**한국어 검색에 유리**합니다.

#### 설정

```sql
-- 2-gram (기본값)
CREATE TABLE articles (
    id INT PRIMARY KEY,
    content TEXT,
    FULLTEXT INDEX idx_content (content) WITH PARSER ngram
);

-- ngram_token_size 설정
SET GLOBAL ngram_token_size = 2;
```

#### 토큰화 예시

**영어 (공백 기준 파싱):**

```
"MySQL is fast"
→ ["MySQL", "is", "fast"]
```

**한국어 (n-gram):**

```
"MySQL은 빠릅니다"

1-gram:
["M", "y", "S", "Q", "L", "은", " ", "빠", "르", "습", "니", "다"]

2-gram (기본):
["My", "yS", "SQ", "QL", "L은", "은 ", " 빠", "빠르", "르습", "습니", "니다"]

3-gram:
["MyS", "ySQ", "SQL", "QL은", "L은 ", "은 빠", " 빠르", "빠르습", "르습니", "습니다"]
```

#### 검색

```sql
-- "빠르" 검색
SELECT * FROM articles
WHERE MATCH(content) AGAINST('빠르' IN BOOLEAN MODE);

-- 2-gram 토큰:
-- ["빠르"]
-- 문서에 "빠르"가 포함되어 있으면 매칭
```

#### 장점

**1) 한국어 형태소 분석 불필요**

```sql
-- 형태소 분석 없이도 검색 가능
"MySQL은 빠릅니다" → "빠르" 검색 시 매칭
```

**2) 부분 문자열 검색**

```sql
-- LIKE '%빠르%'와 유사하지만 훨씬 빠름
SELECT * FROM articles
WHERE MATCH(content) AGAINST('빠르' IN BOOLEAN MODE);
```

#### 단점

**1) 인덱스 크기 증가**

```
"MySQL은 빠릅니다" (8글자)
→ 2-gram: 7개 토큰
→ 3-gram: 6개 토큰

인덱스 크기가 원본보다 클 수 있음
```

**2) 노이즈 증가**

```
"빠르" 검색 시:
- "빠르게", "빠르다", "빠름" 모두 매칭
- 관련도 점수로 필터링 필요
```

---

## 8. 인덱스 설계 실무

### 8.1 인덱스 설계 원칙

**1) 카디널리티가 높은 컬럼에 인덱스 생성**

```sql
-- ✅ Good
CREATE INDEX idx_email ON users (email);  -- 고유값 많음

-- ❌ Bad
CREATE INDEX idx_gender ON users (gender);  -- 고유값 2개 (M, F)
```

**2) WHERE, ORDER BY, GROUP BY 절에 자주 사용되는 컬럼**

```sql
-- 자주 사용되는 쿼리
SELECT * FROM orders
WHERE user_id = ?
ORDER BY created_at DESC;

-- ✅ Good
CREATE INDEX idx_user_created ON orders (user_id, created_at DESC);
```

**3) 복합 인덱스는 등호(=) 조건을 선두에**

```sql
-- ✅ Good
CREATE INDEX idx_status_created ON orders (status, created_at);
-- WHERE status = ? AND created_at > ?

-- ❌ Bad
CREATE INDEX idx_created_status ON orders (created_at, status);
-- 범위 조건이 선두
```

**4) SELECT 절 컬럼을 포함하여 커버링 인덱스 구성**

```sql
-- 쿼리
SELECT order_id, user_id, status
FROM orders
WHERE user_id = ?;

-- ✅ Good (커버링 인덱스)
CREATE INDEX idx_user_status_order ON orders (user_id, status, order_id);
-- 테이블 접근 불필요
```

**5) 인덱스 개수는 최소화 (5~10개 권장)**

```sql
-- 인덱스가 많으면:
-- - INSERT/UPDATE/DELETE 느려짐
-- - 디스크 공간 증가
-- - 옵티마이저 혼란
```

### 8.2 인덱스 안티패턴

**Bad Case 1: 불필요한 인덱스 중복**

```sql
-- ❌ Bad
CREATE INDEX idx_name ON users (name);
CREATE INDEX idx_name_age ON users (name, age);

-- idx_name은 불필요함
-- idx_name_age로 name 단독 검색 가능
```

**Bad Case 2: 모든 컬럼에 인덱스**

```sql
-- ❌ Bad: 무분별한 인덱스 생성
CREATE INDEX idx_col1 ON users (col1);
CREATE INDEX idx_col2 ON users (col2);
CREATE INDEX idx_col3 ON users (col3);
...
CREATE INDEX idx_col20 ON users (col20);

-- 쓰기 성능 심각하게 저하
```

**Bad Case 3: 선택도 낮은 컬럼에 인덱스**

```sql
-- ❌ Bad
CREATE INDEX idx_is_deleted ON users (is_deleted);
-- true: 50만 건, false: 50만 건
-- 인덱스 효과 없음
```

**Bad Case 4: 함수 사용으로 인덱스 무력화**

```sql
-- 인덱스: idx_created (created_at)

-- ❌ Bad
SELECT * FROM orders WHERE YEAR(created_at) = 2023;
-- 함수 사용 → 인덱스 미사용

-- ✅ Good
SELECT * FROM orders
WHERE created_at >= '2023-01-01'
  AND created_at < '2024-01-01';
-- 인덱스 사용
```

### 8.3 실행 계획 (EXPLAIN) 해석

**type 컬럼 (중요도 순):**

```sql
EXPLAIN SELECT * FROM users WHERE id = 100;

+--------+
| type   |
+--------+
```

**성능 순서 (좋음 → 나쁨):**

1. **system**: 테이블에 레코드가 1건만 존재 (거의 없음)
2. **const**: PK 또는 UNIQUE 인덱스로 1건 조회
   ```sql
   WHERE id = 100  -- PK
   ```
3. **eq_ref**: 조인 시 PK 또는 UNIQUE 인덱스 사용
   ```sql
   JOIN orders ON users.id = orders.user_id
   ```
4. **ref**: 일반 인덱스로 등호(=) 검색
   ```sql
   WHERE status = 'ACTIVE'
   ```
5. **range**: 인덱스 범위 검색
   ```sql
   WHERE age BETWEEN 20 AND 30
   ```
6. **index**: 인덱스 풀 스캔
   ```sql
   SELECT id FROM users  -- 커버링 인덱스
   ```
7. **ALL**: 풀 테이블 스캔 (가장 느림)
   ```sql
   SELECT * FROM users WHERE YEAR(created_at) = 2023
   ```

**Extra 컬럼:**

**좋은 경우:**
- `Using index`: 커버링 인덱스 (매우 좋음)
- `Using index condition`: 인덱스 컨디션 푸시다운
- `Using where`: WHERE 절 필터링

**나쁜 경우:**
- `Using filesort`: 정렬 작업 발생 (느림)
- `Using temporary`: 임시 테이블 사용 (느림)
- `Using join buffer`: 조인 버퍼 사용 (인덱스 없음)

### 8.4 인덱스 모니터링

**사용하지 않는 인덱스 찾기:**

```sql
-- MySQL 8.0
SELECT * FROM sys.schema_unused_indexes;

-- 결과:
-- 사용되지 않는 인덱스 목록
-- → 삭제 고려
```

**중복 인덱스 찾기:**

```sql
SELECT * FROM sys.schema_redundant_indexes;

-- 결과:
-- 중복되는 인덱스 목록
-- → 불필요한 인덱스 삭제
```

**인덱스 통계 갱신:**

```sql
-- 인덱스 통계가 부정확하면 잘못된 실행 계획 생성
ANALYZE TABLE users;

-- 주기적으로 실행 권장 (배치 작업)
```

### 8.5 인덱스 설계 체크리스트

**인덱스 생성 전 확인:**

1. 이 쿼리가 자주 실행되는가? (QPS 확인)
2. WHERE 절의 선택도가 5~10% 미만인가?
3. 기존 인덱스로 커버 가능한가?
4. 복합 인덱스 컬럼 순서가 올바른가?
5. 커버링 인덱스 구성 가능한가?

**인덱스 생성 후 확인:**

1. EXPLAIN으로 실행 계획 검증
2. type이 ALL이나 index가 아닌가?
3. Extra에 Using filesort나 Using temporary가 없는가?
4. rows가 예상보다 많지 않은가?

**인덱스 유지보수:**

1. 주기적으로 사용하지 않는 인덱스 삭제
2. 중복 인덱스 제거
3. ANALYZE TABLE로 통계 갱신
4. 슬로우 쿼리 로그 분석 및 인덱스 추가

---

## 정리

### 핵심 원칙

1. **인덱스는 디스크 I/O를 줄이는 것이 목적**
   - 읽어야 할 데이터 양 감소
   - 순차 I/O보다 랜덤 I/O가 느리지만, 읽는 양이 적으면 인덱스가 유리

2. **B-Tree 깊이를 낮추려면 인덱스 키를 작게**
   - 키 크기가 작을수록 페이지 당 저장 개수 증가
   - B-Tree 깊이 감소 → I/O 감소

3. **카디널리티와 선택도를 고려**
   - 고유값이 많은 컬럼에 인덱스 생성
   - 조회 시 전체의 5~10% 미만 반환 시 효과적

4. **복합 인덱스는 컬럼 순서가 핵심**
   - 등호(=) 조건을 선두에
   - 카디널리티 높은 컬럼 우선
   - 범위 조건은 마지막에

5. **커버링 인덱스로 성능 극대화**
   - SELECT 절 컬럼을 인덱스에 포함
   - 테이블 접근 없이 인덱스만 읽음
   - 수십 배 성능 향상

6. **클러스터링 인덱스(PK) 설계 주의**
   - AUTO_INCREMENT 사용 권장
   - 작은 크기 (BIGINT 8바이트)
   - 세컨더리 인덱스 성능에 영향

7. **MySQL 8.0 신기능 활용**
   - 내림차순 인덱스: 혼합 정렬 최적화
   - 함수 기반 인덱스: 함수 사용 쿼리 최적화
   - 인덱스 스킵 스캔: 복합 인덱스 유연성 증가

8. **EXPLAIN으로 실행 계획 검증 필수**
   - type: const, eq_ref, ref, range 확인
   - Extra: Using index (커버링 인덱스) 확인
   - Using filesort, Using temporary 주의
