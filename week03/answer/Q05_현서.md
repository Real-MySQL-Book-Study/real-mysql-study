# B-Tree 인덱스 사용 불가 및 활용 규칙 정리

B-Tree 인덱스는 기본적으로 **왼쪽에서 오른쪽 방향으로(Left-to-Right)** 정렬되어 있습니다. 이 정렬 구조를 깨뜨리는 비교 방식은 인덱스를 '작업 범위 결정 조건'으로 사용할 수 없게 만듭니다.

---

## 1. B-Tree 인덱스 사용 불가 조건 (작업 범위 결정 조건 기준)

아래 조건들은 인덱스 리프 노드의 시작점을 찾을 수 없으므로, 인덱스를 타더라도 전체를 다 읽거나(Index Full Scan), 테이블을 처음부터 끝까지 읽어야(Full Table Scan) 합니다.

### ① NOT-EQUAL 비교 (`<>`, `!=`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`)
* **이유:** 특정 값이 "아닌 것"은 B-Tree 전역에 흩어져 있으므로 시작점을 특정할 수 없습니다.
* **예시:** `WHERE column <> 'ABC'` / `WHERE column NOT IN (10, 20)`

### ② LIKE '%??' (뒷부분 일치 검색)
* **이유:** B-Tree는 왼쪽 문자부터 비교하며 정렬됩니다. 앞부분이 무엇인지 모르면 위치를 찾을 수 없습니다.
* **예시:** `WHERE column LIKE '%서울'` / `WHERE column LIKE '_강남'`

### ③ 인덱스 컬럼의 변형 및 가공 후 비교
* **이유:** 인덱스에는 원본 값이 저장되어 있습니다. 함수를 거쳐 변형된 결과값은 인덱스에 없으므로 비교가 불가능합니다.
* **예시:** `WHERE SUBSTRING(column, 1, 2) = 'AB'` / `WHERE column + 10 > 100`

### ④ NOT DETERMINISTIC 속성의 스토어드 함수 비교
* **이유:** 함수 호출 때마다 결과가 변할 수 있는(비확정적) 함수는 옵티마이저가 비교 범위를 고정할 수 없습니다.
* **예시:** `WHERE column = my_not_deterministic_func()`

### ⑤ 데이터 타입이 서로 다른 비교 (암시적 형변환)
* **이유:** 특히 문자열 컬럼을 숫자형 상수와 비교할 때, MySQL은 컬럼 값을 숫자로 변환합니다(가공 발생).
* **예시:** `WHERE varchar_column = 10` (숫자 10과 비교하기 위해 모든 문자열을 숫자로 바꾸는 과정에서 인덱스 파괴)

### ⑥ 콜레이션(Collation)이 다른 경우
* **이유:** 문자열 데이터의 정렬 규칙(Collation)이 다르면 인덱스의 정렬 순서와 비교 기준이 일치하지 않습니다.
* **예시:** `WHERE utf8mb4_bin_column = utf8mb4_general_ci_column`

---

## 2. 다중 컬럼 인덱스 활용 (Access Condition vs Filter Condition)

다중 컬럼 인덱스 `INDEX (col_1, col_2, col_3, ...)`가 있을 때의 규칙입니다.

### ① 작업 범위 결정 조건으로 사용 "불가"한 경우
인덱스의 왼쪽 컬럼(선행 컬럼)에 대한 조건이 없거나, 위에서 언급한 '사용 불가 조건'이 선행 컬럼에 적용된 경우입니다.

* **예시:** `INDEX (dept_no, emp_no)`
    * `WHERE emp_no = 10001;` 
        * `dept_no` 조건이 없으므로 인덱스의 정렬 구조를 활용해 범위를 좁힐 수 없습니다.
    * `WHERE dept_no LIKE '%A' AND emp_no = 10001;`
        * `dept_no`가 뒷부분 일치 검색이므로 작업 범위를 결정할 수 없습니다.

### ② 작업 범위 결정 조건으로 사용 "가능"한 경우
인덱스의 선행 컬럼부터 순서대로 조건이 존재하며, 그 조건들이 `=` 또는 `범위 비교(<, >)`일 때 사용 가능합니다.

* **공식:** 1. `col_1` (첫 번째 컬럼)에 대한 조건이 존재해야 함.
    2. `col_1`의 비교 연산자가 `IS NULL`, `=`, `IN`, `BETWEEN`, `LIKE 'ABC%'` 중 하나여야 함.
* **예시:** `INDEX (dept_no, emp_no)`
    * `WHERE dept_no = 'D001' AND emp_no > 10000;`
        * `dept_no`와 `emp_no` 모두 작업 범위 결정 조건으로 사용됨.
    * `WHERE dept_no = 'D001';`
        * `dept_no`만 작업 범위 결정 조건으로 사용됨.

---

## 💡 핵심 요약: 체크 조건(Filter Condition)의 의미
위의 불가 조건에 해당하더라도 인덱스에 포함된 컬럼이라면 체크 조건으로 작동할 수 있습니다. 

* **작업 범위 결정 조건:** 인덱스를 통해 읽어야 할 **데이터의 시작점과 끝점을 결정** (성능에 결정적)
* **체크 조건:** 인덱스에서 읽어온 데이터가 **조건에 맞는지 검사** (범위를 줄여주지는 못함)

따라서 최적의 쿼리는 가능한 많은 조건을 '작업 범위 결정 조건'으로 만드는 것입니다.
