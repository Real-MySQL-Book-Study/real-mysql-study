### Q5. B-Tree 인덱스 사용 불가 조건
B-Tree 인덱스를 사용할 수 없는 조건들을 나열하세요.

B-Tree 인덱스를 사용할 수 없는 조건의 핵심은 <br>
인덱스는 정렬되어 있지만, 정렬 순서를 깨뜨리거나 시작점을 알 수 없는 경우.

컬럼을 가공 또는 변경하여 비교하는 경우가 가장 흔한 실수. <br>
```mysql-sql
-- 사용 불가
WHERE salary * 10 > 150000;

-- 사용 가능
WHERE salary > 150000 / 10;
```

LIKE 검색 시 앞부분에 와일드 카드가 있는 경우. <br>
B-Tree 는 왼쪽부터 값을 비교하여 정렬하기 때문에 앞부분이 와일드 카드라면 시작 위치를 찾을 수 없다.
```mysql-sql
-- 사용 불가
WHERE column LIKE '%keyword';
WHERE column LIKE '_keyword';

-- 사용 가능
WHERE column LIKE 'keyword%';
```

복합 인덱스의 순서를 어기는 경우에도 B-Tree 인덱스를 사용할 수 없다.
```mysql-sql
-- 인덱스: (dept_no, emp_no)

-- 사용 불가
WHERE emp_no = 10001;
```

데이터 타입이 서로 다를 때, DB가 내부적으로 형변환을 시도하는데, 컬럼쪽이 변환된다면 이 경우에도 인덱스를 사용할 수 없다.
```mysql-sql
-- 컬럼은 VARCHAR인데 숫자로 비교
WHERE varchar_column = 12345;
-- 내부적으로 WHERE CAST(varchar_column AS INT) = 12345 로 동작하여 인덱스 불가
```


OR 로 연결된 WHERE 조건 중 하나라도 인덱스가 없다면 해당 조건에 의한 풀 테이블 스캔을 해야 하므로 전체적으로 인덱스를 사용할 수 없다. <br>
이 경우, Index Merge 최적화가 발동할 수는 있으나 효율이 좋지 않음.
```mysql-sql
-- col1은 인덱스 있음, col2는 없음
WHERE col1 = 'A' OR col2 = 'B'; -- 풀 테이블 스캔 발생
```

부정형 비교, <>, NOT IN, NOT NULL 등은 일반적으로 인덱스 사용 효율이 매우 떨어져서 <br>
옵티마이저가 풀 테이블 스캔을 선택하는 경우가 많다. <br>
사용 자체가 불가능 하지는 않지만 B-tree 인덱스의 장점인 범위 스캔을 제대로 활용할 수 없기 때문.