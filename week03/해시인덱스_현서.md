# 해시 인덱스(Hash Index)

## 1. 해시 인덱스(Hash Index)란?
해시 인덱스는 키(Key) 값을 해시 함수(Hash Function)에 통과시켜 얻은 결과(해시 값)를 인덱스로 사용하는 방식입니다. 데이터가 저장된 메모리 주소로 바로 점프할 수 있게 도와주는 지도와 같습니다.

### 특징 및 장점
- 극강의 조회 속도: 해시 함수를 한 번 거치면 바로 데이터 위치가 나오므로 조회 성능이 O(1)입니다.
- 효율성: 인메모리 데이터베이스(Redis 등)에서 매우 적은 연산으로 데이터를 찾을 수 있어 성능이 극대화됩니다.

### 치명적인 단점
- 범위 검색 불가: 해시 값은 원본 값이 1만 달라도 완전히 다른 값이 생성되므로, 데이터가 정렬되지 않습니다. 따라서 "특정 범위(>, <, BETWEEN)"나 "문자열 전방 일치(LIKE 'A%')" 검색은 불가능합니다.

---

## 2. Redis와 해시 인덱스
Redis는 기본적으로 "거대한 해시 테이블" 구조를 가진 인메모리 데이터베이스입니다.

### Redis에서 인덱싱이 작동하는 방식
- 기본 인덱스: 사용자가 설정한 Key 자체가 해시 인덱스의 키가 됩니다. `GET user:100`은 O(1)로 처리됩니다.
- 수동 인덱싱 (Manual Indexing): MySQL처럼 `CREATE INDEX` 명령어가 없습니다. 개발자가 보조 인덱스가 필요하면 직접 자료구조를 설계해야 합니다.
    - 예: 나이별 검색이 필요하면 `ZSET` 자료구조에 유저 ID와 나이를 직접 추가(`ZADD`)해야 하며, 원본 데이터가 바뀌면 인덱스용 `ZSET` 데이터도 직접 수정해야 합니다.

---

## 3. RediSearch: 자동화된 인덱싱 툴
최근에는 개발자가 인덱스를 수동으로 관리하는 번거로움을 해결하기 위해 **RediSearch**라는 강력한 모듈이 사용됩니다.

### RediSearch란?
Redis 위에 설치되는 모듈로, RDBMS처럼 선언적으로 인덱스를 만들고 복잡한 쿼리(Full-text search, 복합 검색 등)를 가능하게 해줍니다.

### 간단한 작동 원리
1. 인덱스 정의: 명령어를 통해 특정 해시나 JSON 데이터의 어떤 필드를 인덱싱할지 선언합니다.
2. 역색인(Inverted Index) 구조: 내부적으로 텍스트나 숫자 데이터를 '역색인' 구조로 관리합니다. (엘라스틱서치와 유사한 방식)
3. 자동 동기화: 개발자가 원본 데이터(Hash 등)를 추가/수정하면 RediSearch 모듈이 백그라운드에서 자동으로 인덱스 데이터를 업데이트합니다.
4. 쿼리 최적화: 사용자가 `FT.SEARCH` 명령을 던지면, 모듈이 내부 인덱스를 활용해 빠르게 결과를 찾아 반환합니다.

---

## 4. 요약

| 구분 | 일반적인 해시 인덱스 | Redis (기본) | RediSearch |
| :--- | :--- | :--- | :--- |
| **조회 속도** | $O(1)$ | $O(1)$ | $O(\log N)$ (검색 조건에 따라 상이) |
| **범위 검색** | 불가 | 수동 구현 필요 (ZSET 등) | **지원함** |
| **관리 방식** | 자동 (DB 엔진) | **수동 (개발자 직접 관리)** | **자동 (모듈이 관리)** |
| **주요 용도** | 일치 검색 (=) | 단순 키-값 조회 | 복잡한 조건 검색 및 정렬 |
