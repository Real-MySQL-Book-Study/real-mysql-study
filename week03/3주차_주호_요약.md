# MySQL 인덱스

## 1. 디스크 읽기 방식

인덱스를 사용하는 근본적인 이유는 **디스크 I/O를 줄이기 위함**이다.

### 랜덤 I/O vs 순차 I/O

**순차 I/O (Sequential I/O):** <br>
디스크 헤드가 순서대로 쭉 읽는 방식이다. <br>
풀 테이블 스캔이 여기에 해당한다.

**랜덤 I/O (Random I/O):** <br>
디스크 헤드가 이곳저곳 움직이며 읽는 방식이다. <br>
인덱스 레인지 스캔이 여기에 해당하며, 비용이 높다.

**핵심:** 순차 I/O가 랜덤 I/O보다 훨씬 빠르다. <br>
그럼에도 인덱스를 사용하는 이유는 **읽어야 할 데이터의 양 자체를 줄이기 때문**이다.

### HDD vs SSD

HDD는 물리적인 헤드 이동이 필요하므로 랜덤 I/O에 매우 취약하다. <br>
SSD는 랜덤 I/O 성능이 크게 개선되었지만, 여전히 순차 I/O보다는 느리다. <br>
SSD 환경에서도 인덱스는 여전히 중요하다. 읽어야 할 데이터량을 줄이는 것은 언제나 유효하기 때문이다.

---

## 2. 인덱스 구조와 원리 (B-Tree)

가장 범용적으로 사용되는 인덱스 구조는 **B-Tree (Balanced Tree)**이다.

### B-Tree 구조

**페이지 (Page) / 블록 (Block):** <br>
디스크 읽기/쓰기의 최소 논리 단위이다. (InnoDB 기본 16KB) <br>
버퍼 풀(Buffer Pool)의 관리 단위이기도 하다.

**노드 구조:**
- **루트 노드 (Root):** B-Tree의 최상위 노드
- **브랜치 노드 (Branch):** 중간 노드, 자식 노드로 가는 포인터를 가짐
- **리프 노드 (Leaf):** 최하위 노드, 실제 데이터 레코드의 주소(또는 PK)가 저장됨

```
        [루트 노드]
       /    |     \
  [브랜치] [브랜치] [브랜치]
   /  \     /  \     /  \
[리프][리프][리프][리프][리프][리프]
```

**중요:** 리프 노드에만 실제 데이터 위치 정보가 있다. <br>
루트와 브랜치는 탐색 경로를 안내하는 역할만 한다.

### 인덱스 키 크기와 성능

인덱스 키가 커지면 한 페이지(16KB)에 저장할 수 있는 키 개수가 줄어든다. <br>
→ B-Tree의 깊이(Depth)가 증가한다. <br>
→ 탐색 시 읽어야 할 페이지 수 증가 → **성능 저하**

**예시:**
- 키 크기 16바이트: 페이지당 약 585개 저장 가능
- 키 크기 32바이트: 페이지당 약 372개 저장 가능

따라서 인덱스 키는 가능한 작게 설계해야 한다.

### 기수성 (Cardinality) / 선택도 (Selectivity)

**기수성(Cardinality):** 인덱스 컬럼의 유니크한 값 개수 <br>
**선택도(Selectivity):** 전체 레코드 중 조건을 만족하는 레코드의 비율

**인덱스 효율 공식:**
- Selectivity가 높다 = Cardinality가 높다 = 중복이 적다 = **인덱스 효율이 좋다**

**예시:**
- `gender` 컬럼: 남/여 2종류 → Cardinality 낮음 → 인덱스 비효율
- `email` 컬럼: 사용자마다 고유 → Cardinality 높음 → 인덱스 효율적

---

## 3. 인덱스 스캔 방식

실행 계획(EXPLAIN)의 `type`과 `Extra` 컬럼을 해석할 때 필수적인 개념이다.

### 인덱스 레인지 스캔 (Index Range Scan)

검색 범위가 결정되어 인덱스를 효율적으로 사용하는 가장 일반적인 방식이다.

```sql
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- EXPLAIN type: range
```

**동작 과정:**
1. 인덱스에서 조건을 만족하는 시작 지점을 찾음
2. 리프 노드를 순차적으로 스캔
3. 조건을 만족하지 않는 지점에서 종료

### 인덱스 풀 스캔 (Index Full Scan)

인덱스를 처음부터 끝까지 모두 읽는 방식이다. <br>
테이블 풀 스캔보다는 빠르지만, 효율적이지 않다.

```sql
-- idx_name 인덱스가 있지만 범위 조건이 없는 경우
SELECT name FROM users ORDER BY name;
-- 인덱스 전체를 순회
```

### 루스 인덱스 스캔 (Loose Index Scan)

인덱스를 듬성듬성 건너뛰며 읽는 방식이다. <br>
주로 `GROUP BY` 최적화나 `MIN/MAX` 최적화 시 사용된다.

```sql
SELECT dept_id, MIN(salary) FROM employees GROUP BY dept_id;
-- 각 dept_id 그룹에서 첫 번째 값만 읽으면 됨
-- EXPLAIN Extra: Using index for group-by
```

### 인덱스 스킵 스캔 (Index Skip Scan)

**MySQL 8.0 신기능**이다. <br>
복합 인덱스에서 선행 컬럼 조건이 없어도 인덱스를 사용할 수 있게 해주는 최적화이다.

```sql
-- 인덱스: (gender, age)
-- 기존에는 gender 조건이 없으면 인덱스 사용 불가

-- MySQL 8.0+
SELECT * FROM users WHERE age = 25;
-- 옵티마이저가 gender='M', gender='F' 각각에 대해 age=25를 검색
-- EXPLAIN Extra: Using index for skip scan
```

**제한:** 선행 컬럼의 유니크 값이 적어야 효과적이다.

---

## 4. 인덱스 종류와 특성

### 클러스터링 인덱스 (Clustered Index)

InnoDB의 핵심 개념이다. <br>
**프라이머리 키(PK) 자체가 물리적인 저장 순서를 결정**한다.

**특징:**
- 테이블당 하나만 존재 (PK = 클러스터링 인덱스)
- 리프 노드에 **모든 데이터**가 포함됨 (데이터 파일 = 인덱스)
- PK 순서대로 데이터가 물리적으로 정렬됨

```
클러스터링 인덱스 (PK: id)
[리프 노드]
id=1: (모든 컬럼 데이터)
id=2: (모든 컬럼 데이터)
id=3: (모든 컬럼 데이터)
```

**PK 설계 주의사항:**
- PK가 크면 모든 세컨더리 인덱스 크기도 증가
- PK 변경 시 데이터 물리적 재배치 발생 → 비용 큼
- AUTO_INCREMENT가 INSERT 성능에 유리 (순차 삽입)

### 세컨더리 인덱스 (Secondary Index)

PK를 제외한 나머지 보조 인덱스이다. <br>
리프 노드에 **PK 값**을 저장한다. (데이터 주소가 아님!)

```
세컨더리 인덱스 (idx_email)
[리프 노드]
email='a@test.com': PK=3
email='b@test.com': PK=1
email='c@test.com': PK=2
```

**세컨더리 인덱스로 조회 시:**
1. 세컨더리 인덱스에서 PK 찾기
2. 클러스터링 인덱스에서 PK로 실제 데이터 찾기 (추가 I/O!)

이 때문에 커버링 인덱스가 중요하다.

### 유니크 인덱스 vs 일반 인덱스

**읽기 성능:** 거의 차이 없음 <br>
**쓰기 성능:** 유니크 인덱스가 약간 느림 (유일성 체크 오버헤드)

유니크 인덱스는 중복 체크를 위해 버퍼 풀에 데이터가 없으면 디스크까지 읽어야 한다. <br>
체인지 버퍼(Change Buffer) 사용 불가로 쓰기 지연 최적화도 안 됨.

**결론:** 비즈니스적으로 유니크가 필요한 경우에만 유니크 인덱스를 사용하라.

### 외래키 (Foreign Key)와 잠금

외래키가 설정되면 자식 테이블 INSERT 시 부모 테이블에 공유 락이 전파된다. <br>
이로 인해 데드락 발생 확률이 높아진다.

실무에서는 물리적 FK 제약조건 없이 애플리케이션 레벨에서 검증하는 경우가 많다.

---

## 5. 다중 컬럼 인덱스 (Composite Index)

### 컬럼 순서의 중요성

복합 인덱스에서 **컬럼 순서가 성능을 좌우**한다.

**컬럼 순서 결정 원칙:**
1. **동등 조건(=)** 컬럼을 앞에 배치
2. **범위 조건(<, >, BETWEEN)** 컬럼은 뒤에 배치
3. **정렬(ORDER BY)** 컬럼 고려
4. **기수성이 높은** 컬럼 우선 (논쟁의 여지 있음)

```sql
-- 인덱스: (status, created_at)

-- Good: status가 동등 조건
SELECT * FROM orders
WHERE status = 'PAID' AND created_at > '2023-01-01';

-- Bad: 범위 조건이 앞에 오면 뒤 컬럼 인덱스 활용 불가
-- 인덱스: (created_at, status) 였다면
SELECT * FROM orders
WHERE created_at > '2023-01-01' AND status = 'PAID';
-- created_at 범위 스캔 후 status 필터링 (비효율)
```

### 커버링 인덱스 (Covering Index)

**쿼리에 필요한 모든 컬럼이 인덱스에 포함**되어 있어서, 실제 데이터 파일을 읽지 않고 인덱스만으로 쿼리를 완료하는 것이다.

```sql
-- 인덱스: (user_id, status, created_at)

-- 커버링 인덱스 적용 (테이블 접근 없음)
SELECT user_id, status, created_at FROM orders WHERE user_id = 100;
-- EXPLAIN Extra: Using index

-- 커버링 인덱스 미적용 (테이블 접근 필요)
SELECT * FROM orders WHERE user_id = 100;
-- amount 컬럼 등이 인덱스에 없으므로 테이블 접근 필요
```

**성능 튜닝의 치트키**라고 불릴 만큼 효과가 크다. <br>
세컨더리 인덱스 → 클러스터링 인덱스 조회 단계를 생략할 수 있기 때문이다.

---

## 6. MySQL 8.0 추가 기능

### 내림차순 인덱스 (Descending Index)

MySQL 8.0부터 실제 내부 구조도 내림차순 정렬을 지원한다.

```sql
-- 8.0 이전: ASC 인덱스를 역순으로 읽음 (Backward Index Scan)
-- 8.0 이후: 실제 DESC 인덱스 생성 가능

CREATE INDEX idx_created_desc ON orders (created_at DESC);

SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;
-- 인덱스를 정방향으로 읽으면 됨 (더 효율적)
```

**혼합 정렬에 유용:**
```sql
CREATE INDEX idx_mixed ON orders (user_id ASC, created_at DESC);

SELECT * FROM orders WHERE user_id = 100 ORDER BY created_at DESC;
```

### 함수 기반 인덱스 (Function-Based Index)

컬럼 값을 변형한 결과로 인덱스를 생성한다.

```sql
-- 이메일 도메인으로 검색하는 경우가 많다면
CREATE INDEX idx_email_domain ON users ((SUBSTRING_INDEX(email, '@', -1)));

SELECT * FROM users WHERE SUBSTRING_INDEX(email, '@', -1) = 'gmail.com';
```

### 가상 컬럼 (Virtual Column)

실제 저장되지 않는 계산 컬럼에 인덱스를 생성한다.

```sql
ALTER TABLE users ADD COLUMN email_domain VARCHAR(100)
  AS (SUBSTRING_INDEX(email, '@', -1)) VIRTUAL;

CREATE INDEX idx_email_domain ON users (email_domain);
```

---

## 7. 기타 인덱스 알고리즘

### R-Tree 인덱스

2차원 공간 데이터 저장용이다. (GIS, 위치 기반 서비스) <br>
**MBR(Minimum Bounding Rectangle)** 개념을 사용하여 공간을 사각형으로 감싸서 인덱싱한다.

```sql
CREATE SPATIAL INDEX idx_location ON stores (location);

SELECT * FROM stores
WHERE ST_Contains(ST_GeomFromText('POLYGON(...)'), location);
```

### 전문 검색 인덱스 (Full-text Index)

긴 텍스트 검색용이다. <br>
**역인덱스(Inverted Index)** 구조를 사용한다. (단어 → 문서 ID 매핑)

**불용어(Stopword):** 검색에서 제외할 단어 (a, the, 은, 는 등)

**n-gram 파서:** 본문을 n글자씩 잘라서 인덱싱한다. <br>
한국어처럼 띄어쓰기가 불규칙한 언어 검색에 유리하다.

```sql
CREATE FULLTEXT INDEX idx_content ON posts (content) WITH PARSER ngram;

SELECT * FROM posts WHERE MATCH(content) AGAINST('검색어' IN BOOLEAN MODE);
```

---

## 8. 인덱스 설계 원칙

### 설계 체크리스트

1. **WHERE 절에 자주 사용되는 컬럼**에 인덱스 생성
2. **카디널리티가 높은 컬럼** 우선 고려
3. **복합 인덱스**는 동등 조건 컬럼을 앞에 배치
4. **커버링 인덱스** 가능 여부 검토
5. **인덱스 개수**는 3~5개 이하로 유지 (쓰기 성능 고려)
6. **PK는 가능한 작게** 설계 (모든 세컨더리 인덱스에 영향)

### 안티패턴

**❌ 인덱스 컬럼에 함수/연산 적용:**
```sql
-- Bad: 인덱스 사용 불가
SELECT * FROM users WHERE YEAR(created_at) = 2023;

-- Good: 범위 조건으로 변경
SELECT * FROM users WHERE created_at >= '2023-01-01' AND created_at < '2024-01-01';
```

**❌ 묵시적 형변환:**
```sql
-- phone_number가 VARCHAR인 경우
-- Bad: 숫자로 비교 → 형변환 발생 → 인덱스 사용 불가
SELECT * FROM users WHERE phone_number = 01012345678;

-- Good: 문자열로 비교
SELECT * FROM users WHERE phone_number = '01012345678';
```

**❌ OR 조건의 부분 인덱스:**
```sql
-- idx_a만 있는 경우
-- Bad: b 조건 때문에 풀 스캔 발생 가능
SELECT * FROM t WHERE a = 1 OR b = 2;

-- Good: 각각 인덱스가 있으면 Index Merge 가능
```

### EXPLAIN 해석 포인트

| type | 설명 | 효율 |
|------|------|------|
| const | PK/유니크 키로 1건 조회 | 최고 |
| eq_ref | 조인에서 PK/유니크 키 사용 | 매우 좋음 |
| ref | 인덱스로 여러 행 조회 | 좋음 |
| range | 인덱스 범위 스캔 | 좋음 |
| index | 인덱스 풀 스캔 | 보통 |
| ALL | 테이블 풀 스캔 | 나쁨 |

**Extra 컬럼:**
- `Using index`: 커버링 인덱스 사용 (좋음)
- `Using where`: 스토리지 엔진에서 가져온 후 필터링 (주의)
- `Using filesort`: 정렬을 위해 추가 작업 (개선 필요)
- `Using temporary`: 임시 테이블 사용 (개선 필요)
