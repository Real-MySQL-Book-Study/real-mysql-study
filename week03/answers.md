# Week 3: 인덱스 (1) ⭐ - 답변

## A1. B-Tree 인덱스 구조

**구조**
```
        [루트 노드]
       /    |    \
   [브랜치] [브랜치] [브랜치]
   /  \      |      /  \
[리프][리프][리프][리프][리프]
```

- **루트 노드**: 최상위 노드, 검색 시작점
- **브랜치 노드**: 중간 노드, 리프 노드 위치 정보
- **리프 노드**: 실제 데이터 또는 데이터 위치 저장, 정렬되어 있음

**검색 과정**
1. 루트 노드에서 검색 값의 범위 확인
2. 해당 범위의 브랜치 노드로 이동
3. 리프 노드까지 반복
4. 리프 노드에서 실제 데이터 위치 확인

---

## A2. 클러스터링 인덱스

**정의**
- 프라이머리 키 값 순서대로 데이터가 물리적으로 저장
- InnoDB에서 프라이머리 키 = 클러스터링 인덱스

**특징**
1. 테이블당 하나만 존재
2. 리프 노드에 실제 데이터 저장
3. 프라이머리 키 순서로 정렬된 상태 유지
4. 프라이머리 키가 없으면 유니크 인덱스 또는 내부적으로 생성

**장점**
- 프라이머리 키 검색이 매우 빠름
- 범위 검색에 유리

**단점**
- INSERT 시 정렬 위치를 찾아야 함
- 프라이머리 키 변경 비용이 큼

---

## A3. 세컨더리 인덱스

**데이터 찾아가는 과정**
1. 세컨더리 인덱스에서 조건에 맞는 키 검색
2. 리프 노드에서 프라이머리 키 값 획득
3. 클러스터링 인덱스에서 프라이머리 키로 다시 검색
4. 실제 데이터 반환

**클러스터링 인덱스와의 차이**

| 구분 | 클러스터링 인덱스 | 세컨더리 인덱스 |
|------|-----------------|----------------|
| 개수 | 테이블당 1개 | 여러 개 가능 |
| 리프 노드 | 실제 데이터 | 프라이머리 키 |
| 검색 | 1회 | 2회 (인덱스 + PK 검색) |

---

## A4. 인덱스 키 크기의 영향

**영향**
1. **페이지당 저장 키 감소**
   - 인덱스 페이지 크기 고정 (기본 16KB)
   - 키가 크면 한 페이지에 적은 키 저장
   - 더 많은 페이지 필요 → 메모리/디스크 사용 증가

2. **검색 성능 저하**
   - 더 많은 페이지 읽기 필요
   - 버퍼 풀 효율 감소

3. **세컨더리 인덱스 크기 증가**
   - 세컨더리 인덱스는 프라이머리 키 포함
   - PK가 크면 모든 세컨더리 인덱스도 커짐

---

## A5. B-Tree 인덱스 사용 불가 조건

```sql
-- 1. NOT 조건
WHERE column != 'value'
WHERE NOT column = 'value'

-- 2. LIKE 앞부분 와일드카드
WHERE column LIKE '%value'

-- 3. 인덱스 컬럼 가공
WHERE YEAR(date_column) = 2024
WHERE column * 2 = 100

-- 4. 데이터 타입 불일치 (암묵적 형변환)
WHERE string_column = 12345  -- 문자열 컬럼에 숫자

-- 5. 복합 인덱스에서 선행 컬럼 누락
-- 인덱스: (a, b, c)
WHERE b = 1 AND c = 2  -- a 누락

-- 6. OR 조건 (일부 경우)
WHERE column1 = 'a' OR column2 = 'b'
```

---

## A6. 인덱스 선택도

**정의**
- **카디널리티**: 컬럼의 고유한 값 개수
- **선택도**: 전체 레코드 대비 고유 값 비율

```
선택도 = 카디널리티 / 전체 레코드 수
```

**중요한 이유**
1. 선택도가 높을수록(1에 가까울수록) 인덱스 효율적
2. 선택도가 낮으면 풀 테이블 스캔이 나을 수 있음
3. 옵티마이저가 인덱스 사용 여부 결정에 활용

**예시**
- 성별 컬럼: 카디널리티 2, 선택도 낮음 → 인덱스 비효율
- 주민번호: 카디널리티 높음, 선택도 높음 → 인덱스 효율적

---

## A7. 인덱스 스캔 방식

**인덱스 레인지 스캔 (Index Range Scan)**
- 검색 범위가 결정된 경우
- 시작점 찾고 → 종료점까지 순차 스캔
- 가장 효율적인 방식

**인덱스 풀 스캔 (Index Full Scan)**
- 인덱스 전체를 처음부터 끝까지 스캔
- 테이블 풀 스캔보다는 빠름 (인덱스가 더 작음)
- 커버링 인덱스 활용 시 사용

**루스 인덱스 스캔 (Loose Index Scan)**
- GROUP BY, MAX/MIN 최적화
- 필요한 부분만 듬성듬성 읽음
- 불필요한 인덱스 레코드 스킵

```sql
-- 루스 인덱스 스캔 예시
-- 인덱스: (dept_no, emp_no)
SELECT dept_no, MIN(emp_no)
FROM employees
GROUP BY dept_no;
```

---

## A8. 실무/면접 질문 답변

**자연키 (Natural Key)**
- 비즈니스 의미가 있는 값 (주민번호, 이메일 등)
- 장점: 별도 키 생성 불필요, 의미 파악 쉬움
- 단점: 변경 가능성, 크기가 클 수 있음

**인조키 (Surrogate Key)**
- 비즈니스 의미 없는 자동 생성 값 (AUTO_INCREMENT)
- 장점: 작고 고정된 크기, 변경 없음
- 단점: 추가 컬럼 필요, 조인 시 의미 파악 어려움

**고려 사항**

| 항목 | 자연키 | 인조키 |
|------|-------|--------|
| 크기 | 클 수 있음 | 작음 (4~8 bytes) |
| 변경 가능성 | 있음 | 없음 |
| 세컨더리 인덱스 크기 | 커질 수 있음 | 작게 유지 |
| 페이지 분할 | 랜덤 → 자주 발생 | 순차 → 적음 |
| 의미 전달 | 명확 | 불명확 |

**권장**
- 대부분의 경우 AUTO_INCREMENT 인조키 권장
- 프라이머리 키는 작고 고정된 값이 좋음
- 자연키는 유니크 인덱스로 별도 관리
