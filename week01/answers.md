# Week 1: MySQL 아키텍처 - 답변

## A1. MySQL 서버의 구조

**MySQL 엔진**
- SQL 파싱, 최적화, 실행 계획 수립 담당
- 클라이언트 접속, 쿼리 요청 처리
- 옵티마이저, 파서, 전처리기 포함

**스토리지 엔진**
- 실제 데이터의 읽기/쓰기 담당
- 플러그인 방식으로 여러 엔진 사용 가능 (InnoDB, MyISAM 등)
- InnoDB가 MySQL 8.0의 기본 스토리지 엔진

**관계**
- MySQL 엔진이 스토리지 엔진에 데이터 읽기/쓰기 요청
- Handler API를 통해 통신

---

## A2. InnoDB 버퍼 풀

**역할**
- 디스크에서 읽은 데이터 페이지를 메모리에 캐싱
- 쓰기 작업 시 변경된 데이터를 버퍼 풀에 먼저 기록 (버퍼링)
- 디스크 I/O 최소화로 성능 향상

**크기 설정 시 고려사항**
- 전체 시스템 메모리의 50~80% 권장
- 운영체제와 다른 프로세스를 위한 여유 필요
- `innodb_buffer_pool_size` 파라미터로 설정
- 버퍼 풀 인스턴스 개수도 함께 고려 (`innodb_buffer_pool_instances`)

---

## A3. 언두 로그(Undo Log)

**두 가지 주요 용도**

1. **트랜잭션 롤백**
   - 트랜잭션 실행 중 문제 발생 시 이전 상태로 복구
   - 변경 전 데이터를 언두 로그에 저장

2. **MVCC (Multi-Version Concurrency Control)**
   - 다른 트랜잭션이 변경 중인 데이터를 읽을 때 일관된 읽기 제공
   - 격리 수준에 따라 언두 로그의 이전 버전 데이터 반환

---

## A4. 체인지 버퍼(Change Buffer)

**정의**
- 세컨더리 인덱스 페이지 변경 시 즉시 디스크에 쓰지 않고 버퍼에 저장
- 나중에 해당 페이지가 버퍼 풀에 로드될 때 병합(merge)

**성능 향상 상황**
- INSERT, UPDATE, DELETE가 많은 워크로드
- 세컨더리 인덱스가 많은 테이블
- 랜덤 I/O를 순차 I/O로 변환하여 성능 향상

**제한**
- 유니크 인덱스에는 적용되지 않음 (중복 체크 필요)

---

## A5. 리두 로그(Redo Log)

**역할**
- 커밋된 트랜잭션의 영속성(Durability) 보장
- 서버 비정상 종료 시 데이터 복구에 사용

**WAL(Write-Ahead Logging)**
- 데이터 변경 전에 로그를 먼저 기록하는 방식
- 순서: 리두 로그 기록 → 버퍼 풀 변경 → (나중에) 디스크에 반영
- 순차 쓰기로 성능 향상, 크래시 복구 가능

---

## A6. 어댑티브 해시 인덱스

**정의**
- InnoDB가 자주 접근하는 데이터에 대해 자동으로 생성하는 해시 인덱스
- B-Tree 검색 없이 O(1)로 빠른 조회 가능

**장점**
- 자주 조회되는 데이터에 대한 빠른 접근
- 자동 관리 (DBA 개입 불필요)

**단점**
- 메모리 추가 사용
- 해시 인덱스 생성/유지 오버헤드
- 범위 검색에는 도움되지 않음
- `innodb_adaptive_hash_index`로 비활성화 가능

---

## A7. 스레드 구조

**포그라운드 스레드**
- 클라이언트 연결마다 하나씩 생성
- SQL 문장 처리, 결과 반환
- 데이터 읽기 작업 수행

**백그라운드 스레드**
- 인서트 버퍼 병합
- 리두 로그를 디스크에 기록
- 버퍼 풀의 더티 페이지를 디스크에 기록
- 데드락 감지

---

## A8. 실무/면접 질문 답변

InnoDB는 다음 메커니즘으로 디스크 I/O를 최소화합니다:

1. **버퍼 풀**: 자주 접근하는 데이터를 메모리에 캐싱
2. **체인지 버퍼**: 세컨더리 인덱스 변경을 버퍼링하여 랜덤 I/O 감소
3. **어댑티브 해시 인덱스**: 자주 조회되는 데이터에 빠른 접근
4. **WAL**: 리두 로그로 순차 쓰기 활용
5. **더티 페이지 플러시 최적화**: 백그라운드에서 효율적으로 디스크에 기록
