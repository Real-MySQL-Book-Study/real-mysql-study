# MySQL 트랜잭션과 락

## 1. 트랜잭션 (Transaction)

트랜잭션은 **데이터의 정합성(Consistency)**을 보장하기 위한 기술이다. <br>
하나의 논리적인 작업 셋이 100% 적용되거나 아무것도 적용되지 않아야 한다. (All or Nothing)

### ACID와 원자성

- **Atomicity (원자성)**: 모두 성공하거나 모두 실패
- **Consistency (일관성)**: 데이터의 무결성 제약조건 항상 만족
- **Isolation (격리성)**: 동시 실행 트랜잭션 간 간섭 방지
- **Durability (지속성)**: 커밋된 데이터는 영구 보존

원자성은 **Undo Log**를 통해 구현된다. <br>
트랜잭션 수행 중 오류가 발생하면, Undo Log에 기록된 변경 전 데이터를 이용하여 롤백시켜 데이터 정합성을 맞춘다.

### 트랜잭션 범위의 최소화 (중요)

트랜잭션은 DBMS의 커넥션을 점유한다. <br>
커넥션은 한정된 자원이므로 길게 잡고 있을수록 병목 현상의 원인이 된다.

**Bad Case:**
```
1. 트랜잭션 시작
2. DB 조회
3. 외부 API 호출 (HTTP, 3초 소요) ← 최악의 상황
4. DB 업데이트
5. 커밋
```

**Good Case:**
```
1. DB 조회 (트랜잭션 밖 혹은 읽기 전용)
2. 외부 API 호출
3. 트랜잭션 시작
4. DB 업데이트
5. 커밋
```

**트랜잭션 밖으로 빼야 할 작업:**
- 외부 결제(PG) API 호출
- 이메일 발송 (SMTP)
- SMS, Push 알림
- 외부 REST API 호출
- 파일 업로드/다운로드

외부 시스템과의 통신은 네트워크 장애 등으로 인해 타임아웃이 발생할 수 있으므로, 반드시 트랜잭션 범위 밖으로 빼내야 한다.

---

## 2. MySQL 엔진 잠금

스토리지 엔진(InnoDB) 레벨이 아니라, MySQL 엔진 레벨에서 관리되는 락이다. <br>
모든 스토리지 엔진에 영향을 미친다.

### 글로벌 락 (Global Lock)

`FLUSH TABLES WITH READ LOCK` 명령으로 획득한다. <br>
가장 범위가 크며, SELECT를 제외한 모든 DDL, DML 문장이 대기 상태가 된다. <br>
주로 mysqldump 등으로 데이터베이스 전체 백업을 받아야 할 때 사용한다. <br>
InnoDB는 트랜잭션을 지원하므로 최근에는 잘 사용하지 않는 추세이다.

### 테이블 락 (Table Lock)

개별 테이블 단위로 잠금한다. <br>
InnoDB는 레코드 기반 락을 쓰기 때문에 DML(INSERT, UPDATE 등)에서는 거의 발생하지 않는다. <br>
DDL(스키마 변경) 수행 시 묵시적으로 발생하여 운영 중인 서비스에 영향을 줄 수 있다.

```sql
LOCK TABLES user WRITE;
-- 작업 수행
UNLOCK TABLES;
```

### 네임드 락 (Named Lock)

`GET_LOCK()`, `RELEASE_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정한다. <br>
테이블이나 레코드 같은 DB 객체가 아니라 사용자가 지정한 임의의 문자열에 잠금을 거는 방식이다.

```sql
-- 락 획득 (10초 대기)
SELECT GET_LOCK('my_lock_name', 10);
-- 비즈니스 로직 수행
-- 락 해제
SELECT RELEASE_LOCK('my_lock_name');
```

**활용처:** <br>
여러 인스턴스(WAS)가 동시에 돌아가는 분산 환경에서, DB 레코드 락만으로는 동시성 제어가 힘들 때 **분산 락(Distributed Lock)**을 구현하는 데 유용하게 쓰인다. <br>
예: 배치 작업 중복 방지, 선착순 이벤트, 재고 차감 등에서 Redis 분산 락의 대안으로 사용

**장점:** Redis 없이 분산 락 구현 가능, DB 커넥션만 있으면 사용 가능 <br>
**단점:** DB 커넥션 점유 (커넥션 풀 고갈 주의), Redis보다 성능 낮음

### 메타데이터 락 (Metadata Lock)

테이블의 구조(이름 변경 등)를 변경할 때 자동으로 획득하는 락이다. <br>
사용자가 직접 요청할 수 없으며 MySQL 서버가 자동으로 획득한다.

SELECT, INSERT 등이 실행될 때 테이블 구조가 변경되면 안되므로 쿼리 실행 중에 **Shared MDL**이 걸려 구조 변경을 막는다. <br>
반대로, 스키마 변경 시에는 **Exclusive MDL**이 걸려 다른 트랜잭션의 읽기/쓰기를 모두 막는다.

**주의:** 운영 중인 테이블의 구조를 바꿀 때 장시간 트랜잭션이 실행 중이라면 이 락 때문에 서비스 전체가 멈출 수 있다.

---

## 3. InnoDB 스토리지 엔진 잠금

InnoDB 락의 가장 큰 특징은 **"레코드 자체가 아니라, 인덱스(Index)를 잠근다"**는 것이다.

### 레코드 락 (Record Lock)

실제 레코드(데이터)가 아닌 **인덱스 레코드**를 잠근다. <br>
인덱스가 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

```sql
-- id는 PRIMARY KEY (인덱스)
UPDATE users SET name = '홍길동' WHERE id = 100;
-- id=100 인덱스 레코드만 잠금
```

### 갭 락 (Gap Lock)

레코드 자체가 아니라, 레코드와 레코드 사이의 **비어있는 간격(Gap)**을 잠근다. <br>
새로운 레코드가 그 사이에 INSERT 되는 것을 막는다. <br>
이를 통해 **Phantom Read**(같은 트랜잭션 내에서 없던 데이터가 조회되는 현상)를 방지한다.

```sql
-- id: 1, 5, 10이 존재하는 상황
SELECT * FROM users WHERE id BETWEEN 3 AND 7 FOR UPDATE;
-- Gap [1, 5), [5, 10) 잠금 → id=6 INSERT 불가
```

### 넥스트 키 락 (Next-Key Lock)

**레코드 락 + 갭 락**의 형태이다. <br>
InnoDB의 기본 잠금 방식이며, 바이너리 로그(Binary Log)를 이용한 레플리카 서버와의 데이터 정합성을 위해 사용된다.

### 자동 증가 락 (Auto Increment Lock)

AUTO_INCREMENT 컬럼에 값이 채번될 때 서로 겹치지 않게 하기 위한 테이블 수준의 가벼운 락이다. <br>
INSERT 쿼리 실행 중에만 잠깐 획득하며, 트랜잭션과 무관하게 즉시 해제된다.

---

## 4. 인덱스와 잠금 (매우 중요)

"InnoDB는 인덱스를 잠근다"는 특성 때문에 발생하는 치명적인 시나리오를 이해해야 한다.

### 문제 상황

```sql
-- last_name 컬럼에는 인덱스가 없다고 가정
UPDATE user SET level = 'VIP' WHERE last_name = 'Kim';
```

**내부 동작:**
1. 풀 테이블 스캔 발생 (인덱스 없음)
2. PRIMARY KEY의 모든 레코드를 순회하며 잠금
3. `last_name = 'Kim'` 조건을 만족하는 레코드만 실제 변경
4. **하지만 잠금은 전체 테이블에 걸림!**

**결과:** 'Kim' 씨만 업데이트하려다 전체 사용자의 업데이트가 불가능해지는 장애가 발생한다.

### 해결 방법

```sql
-- 인덱스 추가
ALTER TABLE users ADD INDEX idx_last_name (last_name);
-- 이후 동일한 쿼리 실행 시 조건 만족 레코드만 잠금
```

### 실무 체크리스트

UPDATE/DELETE 쿼리 작성 시 반드시 실행 계획을 확인해야 한다.

```sql
EXPLAIN UPDATE users SET level = 'VIP' WHERE last_name = 'Kim';
-- type 컬럼 확인:
-- ALL (풀 테이블 스캔) → 위험! 인덱스 추가 필요
-- range, ref, eq_ref → 안전
```

**교훈:** UPDATE, DELETE 문장 실행 시 조건절에 사용되는 컬럼이 인덱스를 잘 타고 있는지 반드시 확인해야 한다.

---

## 5. 트랜잭션 격리 수준 (Isolation Level)

동시성(Concurrency)과 데이터 정합성(Consistency)은 반비례 관계이다.

### READ UNCOMMITTED

커밋되지 않은 데이터도 다른 트랜잭션에서 보인다. (**Dirty Read**) <br>
데이터 정합성에 심각한 문제가 있어 실무에서는 거의 쓰지 않는다.

### READ COMMITTED

커밋된 데이터만 보인다. <br>
**Non-Repeatable Read** 발생: 트랜잭션 내에서 똑같은 SELECT를 두 번 했는데, 그 사이에 다른 트랜잭션이 값을 바꾸고 커밋하면 결과가 달라진다. <br>
Oracle, PostgreSQL의 기본값이다.

### REPEATABLE READ (MySQL InnoDB 기본값)

트랜잭션이 시작된 시점의 상태(Snapshot)를 유지하며 데이터를 읽는다. <br>
**MVCC(Multi-Version Concurrency Control)**를 이용해 Undo Log에 있는 이전 버전의 데이터를 보여준다. <br>
트랜잭션 내에서 SELECT 결과가 항상 동일함을 보장한다.

일반적인 DBMS에서는 Phantom Read가 발생하지만, MySQL InnoDB는 넥스트 키 락 덕분에 발생하지 않거나 최소화된다.

### SERIALIZABLE

가장 엄격한 수준이다. <br>
읽기 작업에도 공유 락(Shared Lock)을 건다. <br>
동시 처리 성능이 급격히 떨어지므로 실무에서 거의 사용하지 않는다.

### 격리 수준 비교

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 실무 사용 |
|-----------|------------|---------------------|--------------|-----------|
| READ UNCOMMITTED | O | O | O | X |
| READ COMMITTED | X | O | O | Oracle, PostgreSQL |
| REPEATABLE READ | X | X | X (InnoDB) | MySQL 기본값 |
| SERIALIZABLE | X | X | X | X |

---

## 6. 심화 학습 주제

### MVCC (Multi-Version Concurrency Control)

**핵심:** 잠금 없는 일관된 읽기(Non-Locking Consistent Read) <br>
쓰기 작업 중에도 읽기 작업은 대기하지 않고 Undo Log의 데이터를 읽는다.

이 메커니즘을 이해해야 긴 트랜잭션이 Undo Log를 급증시켜 DB 성능을 저하시키는 원인을 파악할 수 있다.

### 레플리케이션과 넥스트 키 락

**의문:** 왜 InnoDB는 굳이 갭 락을 써서 동시성을 저해할까?

**핵심:** 바이너리 로그(Binlog) 포맷이 STATEMENT 기반일 때, Master와 Slave 간의 데이터 불일치를 막기 위함이다. <br>
최근에는 ROW 기반 포맷을 많이 쓰면서 락 범위를 줄이려는 시도도 많다.

### 데드락 (Deadlock) 분석

두 개 이상의 트랜잭션이 서로의 락을 기다리며 무한 대기하는 상황이다. <br>
`SHOW ENGINE INNODB STATUS` 명령어를 통해 데드락이 발생한 쿼리와 락의 종류를 해석하는 방법을 연습해야 한다.

**데드락 최소화 전략:**
- 트랜잭션 순서 통일 (항상 users → orders 순서로 잠금)
- 트랜잭션 크기 최소화
- 배치 크기 제한 (LIMIT 사용)

### 외래키(Foreign Key)와 락의 전파

외래키가 설정되어 있으면 자식 테이블에 INSERT 할 때 부모 테이블의 레코드를 확인하기 위해 공유 락이 전파된다. <br>
이로 인해 데드락 발생 확률이 높아지므로, 실무(특히 대용량 트래픽 환경)에서는 물리적인 FK 제약조건을 걸지 않고 애플리케이션 레벨에서 검증하는 경우가 많다.

### 낙관적 락 vs 비관적 락

**낙관적 락 (Optimistic Lock):** <br>
충돌이 드물다고 가정하고, 커밋 시점에 충돌을 감지한다. <br>
애플리케이션 레벨에서 버전 컬럼(@Version)을 이용하여 구현한다. <br>
충돌 시 예외 발생 → 재시도 필요

**비관적 락 (Pessimistic Lock):** <br>
충돌이 자주 발생한다고 가정하고, 미리 락을 획득한다. <br>
DB 레벨의 `SELECT FOR UPDATE`로 구현한다. <br>
락 대기 시간 발생, 데드락 위험 있음

**선택 기준:**
- 충돌이 적은 경우 → 낙관적 락 유리 (조회수 증가 등)
- 충돌이 잦은 경우 → 비관적 락 필요 (재고 감소, 좌석 예약, 포인트 차감 등)