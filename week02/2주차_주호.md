# MySQL 트랜잭션과 락 심화 학습

## 목차
1. [트랜잭션 (Transaction)](#1-트랜잭션-transaction)
2. [MySQL 엔진 잠금](#2-mysql-엔진-잠금)
3. [InnoDB 스토리지 엔진 잠금](#3-innodb-스토리지-엔진-잠금)
4. [인덱스와 잠금](#4-인덱스와-잠금)
5. [트랜잭션 격리 수준](#5-트랜잭션-격리-수준)
6. [심화 학습 주제](#6-심화-학습-주제)

---

## 1. 트랜잭션 (Transaction)

### 1.1 개념

트랜잭션은 **작업의 완전성을 보장**해주는 기술입니다.

하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이, **논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 합니다.**

### 1.2 ACID와 원자성 (Atomicity)

- **A**tomicity (원자성): All or Nothing - 모두 성공하거나 모두 실패
- **C**onsistency (일관성): 데이터의 무결성 제약조건 항상 만족
- **I**solation (격리성): 동시 실행 트랜잭션 간 간섭 방지
- **D**urability (지속성): 커밋된 데이터는 영구 보존

**Undo Log를 통한 롤백 구현:**
- InnoDB는 변경 전 데이터를 Undo Log에 백업
- 롤백 시 Undo Log의 데이터를 복원하여 원자성 보장
- MVCC(Multi-Version Concurrency Control)의 핵심 메커니즘

### 1.3 트랜잭션 범위 최소화 (매우 중요)

트랜잭션은 **DBMS 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용**하는 것이 좋습니다.

#### Bad Case: 트랜잭션 내부에서 외부 시스템 호출

```java
// ❌ 잘못된 예시: 트랜잭션이 불필요하게 길어짐
@Transactional
public void processOrder(Order order) {
    // 1. 주문 저장 (DB 작업 - 필수)
    orderRepository.save(order);

    // 2. 외부 결제 API 호출 (3~5초 소요)
    paymentGateway.processPayment(order);  // 트랜잭션이 길어짐!

    // 3. 이메일 발송 (1~2초 소요)
    emailService.sendConfirmation(order);  // 트랜잭션이 더 길어짐!

    // 4. Push 알림 (1초 소요)
    pushService.sendNotification(order);   // 트랜잭션이 계속 길어짐!

    // 5. 주문 상태 업데이트 (DB 작업 - 필수)
    order.setStatus(OrderStatus.COMPLETED);
}
```

**문제점:**
- 트랜잭션이 7~10초 이상 유지됨
- DB 커넥션 점유 시간 증가 → 동시성 저하
- 외부 API 장애 시 트랜잭션 롤백 → 데이터 정합성 문제
- 락(Lock) 보유 시간 증가 → 다른 트랜잭션 대기

#### Good Case: 외부 호출을 트랜잭션 밖으로 분리

```java
// ✅ 올바른 예시: 트랜잭션 범위 최소화
public void processOrder(Order order) {
    // 1. 외부 결제 API 호출 (트랜잭션 밖)
    PaymentResult paymentResult = paymentGateway.processPayment(order);

    if (!paymentResult.isSuccess()) {
        throw new PaymentFailedException("결제 실패");
    }

    // 2. DB 작업만 트랜잭션으로 묶기 (0.1초 이내)
    saveOrderWithTransaction(order, paymentResult);

    // 3. 이메일, Push는 비동기로 처리 (트랜잭션 밖)
    asyncNotificationService.sendConfirmation(order);
}

@Transactional
private void saveOrderWithTransaction(Order order, PaymentResult result) {
    order.setPaymentId(result.getPaymentId());
    order.setStatus(OrderStatus.COMPLETED);
    orderRepository.save(order);
}
```

**개선 효과:**
- 트랜잭션 시간: 7~10초 → **0.1초 이내**
- DB 커넥션 점유 최소화
- 외부 API 장애와 DB 트랜잭션 분리
- 동시 처리 가능한 트랜잭션 수 증가

### 1.4 외부 시스템 처리 가이드

**트랜잭션 밖으로 빼야 할 작업:**
- 외부 결제(PG) API 호출
- 이메일 발송 (SMTP)
- SMS, Push 알림
- 외부 REST API 호출
- 파일 업로드/다운로드
- 외부 저장소 접근 (S3, CDN)

**트랜잭션에 포함해야 할 작업:**
- DB INSERT, UPDATE, DELETE
- 여러 테이블 간 정합성 보장이 필요한 작업
- FK 제약조건이 걸린 연관 데이터 변경

---

## 2. MySQL 엔진 잠금

MySQL 엔진 레벨의 락은 **모든 스토리지 엔진에 영향**을 미칩니다.

### 2.1 글로벌 락 (Global Lock)

**가장 범위가 넓은 락**으로, MySQL 서버 전체에 영향을 미칩니다.

```sql
FLUSH TABLES WITH READ LOCK;
```

**특징:**
- **모든 테이블**에 대한 쓰기 작업 차단 (SELECT는 가능)
- DDL(CREATE, ALTER, DROP) 명령 차단
- 주로 `mysqldump` 백업 시 데이터 일관성 보장을 위해 사용
- 웹 서비스에서는 절대 사용 금지 (전체 서비스 멈춤)

**대안:**
- InnoDB 사용 시 `--single-transaction` 옵션으로 백업 (락 없이 백업 가능)
- 레플리카 서버에서 백업 수행

### 2.2 테이블 락 (Table Lock)

**테이블 단위의 락**입니다.

```sql
LOCK TABLES user WRITE;
-- 작업 수행
UNLOCK TABLES;
```

**명시적 획득:**
- `LOCK TABLES` 명령으로 직접 획득
- 실무에서는 거의 사용하지 않음

**묵시적 획득:**
- DDL 쿼리 실행 시 자동 획득
- `ALTER TABLE`, `DROP TABLE`, `TRUNCATE TABLE` 등

**InnoDB의 경우:**
- DML(INSERT, UPDATE, DELETE)은 레코드 기반 락 사용 → 테이블 락 미발생
- DDL만 테이블 락 발생

### 2.3 네임드 락 (Named Lock)

**임의의 문자열에 대한 잠금**을 제공하는 사용자 정의 락입니다.

```sql
-- 락 획득 (10초 대기)
SELECT GET_LOCK('my_lock_name', 10);

-- 비즈니스 로직 수행

-- 락 해제
SELECT RELEASE_LOCK('my_lock_name');
```

**활용 사례:**

**1) 분산 락 구현 (Redis 대안)**

```java
public class MySQLDistributedLock {

    private static final String LOCK_NAME = "order_process_lock";
    private static final int TIMEOUT_SECONDS = 10;

    public void processWithLock(String orderId) {
        String lockKey = LOCK_NAME + ":" + orderId;

        // 락 획득
        boolean acquired = jdbcTemplate.queryForObject(
            "SELECT GET_LOCK(?, ?)",
            Boolean.class,
            lockKey,
            TIMEOUT_SECONDS
        );

        if (!acquired) {
            throw new LockAcquisitionException("락 획득 실패");
        }

        try {
            // 비즈니스 로직 (중복 방지)
            processOrder(orderId);
        } finally {
            // 락 해제
            jdbcTemplate.queryForObject(
                "SELECT RELEASE_LOCK(?)",
                Boolean.class,
                lockKey
            );
        }
    }
}
```

**2) 배치 작업 중복 실행 방지**

```sql
-- 배치 작업 시작 전
SELECT GET_LOCK('daily_batch_job', 0);  -- 0: 즉시 반환

-- 락을 얻지 못하면 이미 다른 인스턴스에서 실행 중
```

**장점:**
- Redis 없이 분산 락 구현 가능
- DB 커넥션만 있으면 사용 가능

**단점:**
- DB 커넥션 점유 (커넥션 풀 고갈 주의)
- Redis보다 성능 낮음

### 2.4 메타데이터 락 (Metadata Lock)

**테이블의 메타데이터(구조)를 보호**하는 락입니다.

**자동 획득:**
- 테이블 구조 변경 시 자동으로 획득됨
- 명시적으로 획득/해제 불가능

**시나리오:**

```sql
-- Session 1: 긴 쿼리 실행 중
SELECT * FROM users WHERE created_at > '2023-01-01';  -- 10초 소요

-- Session 2: 테이블 구조 변경 시도
ALTER TABLE users ADD COLUMN phone VARCHAR(20);  -- 대기 발생!
```

**문제 상황:**
- 긴 SELECT 쿼리 실행 중 → 메타데이터 공유 락 보유
- ALTER TABLE 시도 → 메타데이터 배타 락 필요 → 대기
- 새로운 SELECT 쿼리들도 대기 → 서비스 장애

**해결책:**
- Online DDL 사용 (MySQL 5.6+)
- `pt-online-schema-change` 도구 사용
- 트래픽이 적은 시간대에 DDL 수행

---

## 3. InnoDB 스토리지 엔진 잠금

InnoDB는 **스토리지 엔진 내부에서 레코드 기반의 잠금**을 제공합니다.

### 핵심 특징: "레코드가 아니라 인덱스를 잠근다"

**InnoDB의 잠금은 항상 인덱스를 기준으로 동작합니다.**

### 3.1 레코드 락 (Record Lock)

**인덱스 레코드 자체를 잠그는 락**입니다.

```sql
-- id는 PRIMARY KEY (인덱스)
UPDATE users SET name = '홍길동' WHERE id = 100;
```

**특징:**
- **인덱스 레코드**를 잠금 (테이블 레코드가 아님!)
- 다른 트랜잭션은 해당 레코드를 변경/삭제 불가
- 읽기는 가능 (MVCC 덕분)

### 3.2 갭 락 (Gap Lock)

**레코드와 레코드 사이의 간격(Gap)을 잠그는 락**입니다.

**목적: Phantom Read 방지**

```sql
-- id: 1, 5, 10이 존재하는 상황

-- Transaction 1
SELECT * FROM users WHERE id BETWEEN 3 AND 7 FOR UPDATE;
-- Gap [1, 5), [5, 10) 잠금

-- Transaction 2
INSERT INTO users (id, name) VALUES (6, '신규');  -- 대기 발생!
```

**특징:**
- 새로운 레코드 삽입 방지
- REPEATABLE READ 격리 수준에서 작동
- 읽기 일관성 보장

**갭 락이 잠그는 범위:**
- `WHERE id > 5`: (5, +∞) 잠금
- `WHERE id BETWEEN 3 AND 7`: (1, 5), (5, 10) 잠금
- `WHERE id < 10`: (-∞, 1), (1, 5), (5, 10) 잠금

### 3.3 넥스트 키 락 (Next-Key Lock)

**레코드 락 + 갭 락을 결합한 락**입니다.

**InnoDB의 기본 잠금 방식**입니다.

```sql
-- id: 1, 5, 10이 존재

SELECT * FROM users WHERE id <= 7 FOR UPDATE;

-- 잠금 범위:
-- 레코드: id=1, id=5 (레코드 락)
-- 갭: (-∞, 1), (1, 5), (5, 10) (갭 락)
```

**중요성:**
- **MySQL Replication의 데이터 정합성 보장**
- Binlog STATEMENT 형식에서 필수
- Phantom Read 완벽 차단

**레플리케이션과의 관계:**

```sql
-- Master 서버
DELETE FROM users WHERE created_at < '2023-01-01';  -- 100건 삭제

-- Binlog에 기록:
-- DELETE FROM users WHERE created_at < '2023-01-01';

-- Slave 서버에서 재실행 시:
-- 만약 갭 락이 없다면, Master에서 삭제 중 Slave에서 새 레코드 추가 가능
-- → Slave에서 다른 결과 발생 (데이터 불일치)

-- 넥스트 키 락 덕분에:
-- 삭제 대상 범위에 새 레코드 삽입 차단 → 정합성 보장
```

### 3.4 자동 증가 락 (Auto Increment Lock)

**AUTO_INCREMENT 컬럼의 채번을 위한 테이블 레벨 락**입니다.

```sql
INSERT INTO users (name) VALUES ('홍길동');  -- id 자동 증가
```

**특징:**
- INSERT 쿼리 실행 중에만 잠깐 획득 (매우 짧음)
- 트랜잭션과 무관하게 즉시 해제
- 동시에 여러 INSERT 시 순서 보장

**락 모드 설정:**

```sql
-- innodb_autoinc_lock_mode 설정
-- 0: 전통적인 방식 (모든 INSERT에 테이블 락)
-- 1: 연속 모드 (단순 INSERT는 뮤텍스, LOAD DATA는 테이블 락)
-- 2: 인터리브 모드 (모두 뮤텍스, 빠르지만 Binlog STATEMENT 모드 불가)
```

**권장 설정:**
- MySQL 8.0+: `innodb_autoinc_lock_mode = 2` (기본값)
- Binlog는 ROW 형식 사용 (STATEMENT 미사용)

---

## 4. 인덱스와 잠금

### 핵심 원칙: InnoDB는 "레코드가 아니라 인덱스를 잠근다"

**인덱스가 없는 컬럼 조건으로 UPDATE/DELETE 시 전체 레코드 잠금 위험!**

### 4.1 문제 상황

**테이블 구조:**

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE,
    last_name VARCHAR(50),  -- 인덱스 없음!
    level VARCHAR(20),
    INDEX idx_email (email)
);

-- 데이터: 1,000,000건
```

**Bad Case: 인덱스 없는 컬럼으로 UPDATE**

```sql
-- last_name에 인덱스가 없는 상황
UPDATE users SET level = 'VIP' WHERE last_name = 'Kim';
```

**내부 동작:**

1. **풀 테이블 스캔 발생** (인덱스 없음)
2. **PRIMARY KEY의 모든 레코드를 순회하며 잠금**
3. `last_name = 'Kim'` 조건을 만족하는 레코드만 실제 변경
4. **하지만 잠금은 전체 테이블에 걸림!**

**결과:**
- 1,000,000건 모두 잠금
- 실제 변경은 100건 (last_name='Kim')
- 다른 트랜잭션의 모든 UPDATE/DELETE 대기 → **서비스 장애**

### 4.2 해결 방법

**Good Case: 인덱스 추가**

```sql
-- 1. 인덱스 생성
ALTER TABLE users ADD INDEX idx_last_name (last_name);

-- 2. 동일한 쿼리 실행
UPDATE users SET level = 'VIP' WHERE last_name = 'Kim';
```

**개선 효과:**
- 잠금 대상: 1,000,000건 → **100건**
- 인덱스 스캔으로 조건 만족 레코드만 잠금
- 다른 트랜잭션 정상 동작

### 4.3 실무 체크리스트

**UPDATE/DELETE 쿼리 작성 시 필수 확인:**

```sql
-- 1. 실행 계획 확인
EXPLAIN UPDATE users SET level = 'VIP' WHERE last_name = 'Kim';

-- type 컬럼 확인:
-- ALL (풀 테이블 스캔) → 위험! 인덱스 추가 필요
-- range, ref, eq_ref → 안전
```

**2. 잠금 대상 레코드 수 확인:**

```sql
-- 실제 변경 전 영향 범위 확인
SELECT COUNT(*) FROM users WHERE last_name = 'Kim';
-- 100건 → 안전

SELECT COUNT(*) FROM users WHERE last_name = 'Kim';
-- 900,000건 → 위험! 조건 재검토 또는 배치 처리
```

**3. 복합 조건 시 인덱스 순서 확인:**

```sql
-- 인덱스: idx_created_status (created_at, status)

-- Good: 인덱스 선두 컬럼 사용
UPDATE users SET level = 'VIP'
WHERE created_at > '2023-01-01' AND status = 'ACTIVE';

-- Bad: 인덱스 선두 컬럼 미사용
UPDATE users SET level = 'VIP'
WHERE status = 'ACTIVE';  -- created_at 조건 없음 → 인덱스 미사용
```

### 4.4 예시: 실제 장애 시나리오

**상황:**

```sql
-- 매일 자정에 실행되는 배치 작업
UPDATE orders
SET status = 'EXPIRED'
WHERE payment_status = 'PENDING'
  AND created_at < DATE_SUB(NOW(), INTERVAL 7 DAY);
```

**문제:**
- `payment_status` 컬럼에 인덱스 없음
- 1천만 건의 orders 테이블 풀 스캔
- 10분간 전체 테이블 잠금
- 새로운 주문 INSERT 불가 → 서비스 장애

**해결:**

```sql
-- 1. 복합 인덱스 추가
ALTER TABLE orders
ADD INDEX idx_payment_created (payment_status, created_at);

-- 2. 배치 크기 제한
UPDATE orders
SET status = 'EXPIRED'
WHERE payment_status = 'PENDING'
  AND created_at < DATE_SUB(NOW(), INTERVAL 7 DAY)
LIMIT 1000;  -- 1000건씩 처리
```

**교훈:**
- **UPDATE, DELETE 쿼리는 항상 인덱스 확인 필수**
- 대량 변경 시 LIMIT으로 배치 처리
- 실행 계획(EXPLAIN)으로 검증

---

## 5. 트랜잭션 격리 수준

트랜잭션 격리 수준은 **동시에 처리되는 트랜잭션들이 서로의 변경 데이터를 어느 정도까지 볼 수 있게 할지**를 결정합니다.

### 5.1 READ UNCOMMITTED

**커밋되지 않은 데이터를 읽을 수 있는 격리 수준**입니다.

**Dirty Read 발생:**

```sql
-- Transaction 1
START TRANSACTION;
UPDATE users SET level = 'VIP' WHERE id = 1;
-- 아직 커밋 안 함

-- Transaction 2
SELECT level FROM users WHERE id = 1;
-- 결과: 'VIP' (커밋 안 된 데이터 읽힌다!)

-- Transaction 1
ROLLBACK;  -- 롤백!

-- Transaction 2의 읽은 데이터는 이제 유효하지 않음 (Dirty Read)
```

**특징:**
- 가장 낮은 격리 수준
- 성능은 가장 좋음
- **실무에서 절대 사용 금지** (데이터 정합성 보장 불가)

### 5.2 READ COMMITTED

**커밋된 데이터만 읽을 수 있는 격리 수준**입니다.

**Oracle, PostgreSQL의 기본값**입니다.

**Dirty Read 방지:**

```sql
-- Transaction 1
START TRANSACTION;
UPDATE users SET level = 'VIP' WHERE id = 1;

-- Transaction 2
SELECT level FROM users WHERE id = 1;
-- 결과: 'NORMAL' (커밋 전 데이터는 보이지 않음 - Undo Log 읽음)

-- Transaction 1
COMMIT;

-- Transaction 2
SELECT level FROM users WHERE id = 1;
-- 결과: 'VIP' (커밋 후 읽힌다)
```

**Non-Repeatable Read 발생:**

```sql
-- Transaction 1
START TRANSACTION;
SELECT level FROM users WHERE id = 1;
-- 결과: 'NORMAL'

-- Transaction 2
UPDATE users SET level = 'VIP' WHERE id = 1;
COMMIT;

-- Transaction 1
SELECT level FROM users WHERE id = 1;
-- 결과: 'VIP' (같은 트랜잭션 내에서 다른 결과!)
```

**특징:**
- Dirty Read 방지
- Non-Repeatable Read 발생 가능
- 성능과 정합성의 균형

### 5.3 REPEATABLE READ

**트랜잭션 내에서 동일한 SELECT 결과를 보장하는 격리 수준**입니다.

**MySQL InnoDB의 기본값**입니다.

**MVCC로 스냅샷 유지:**

```sql
-- Transaction 1 (트랜잭션 ID: 10)
START TRANSACTION;
SELECT level FROM users WHERE id = 1;
-- 결과: 'NORMAL'
-- 스냅샷 시점: 트랜잭션 ID 10

-- Transaction 2 (트랜잭션 ID: 11)
UPDATE users SET level = 'VIP' WHERE id = 1;
COMMIT;

-- Transaction 1
SELECT level FROM users WHERE id = 1;
-- 결과: 'NORMAL' (트랜잭션 10 시점의 스냅샷 유지!)
-- Undo Log에서 트랜잭션 10 이전 버전 읽음
```

**Phantom Read 방지:**

```sql
-- Transaction 1
START TRANSACTION;
SELECT COUNT(*) FROM users WHERE age BETWEEN 20 AND 30;
-- 결과: 100

-- Transaction 2
INSERT INTO users (age, name) VALUES (25, '신규');
COMMIT;

-- Transaction 1
SELECT COUNT(*) FROM users WHERE age BETWEEN 20 AND 30;
-- 결과: 100 (넥스트 키 락 덕분에 새 레코드 삽입 차단됨)
```

**특징:**
- Non-Repeatable Read 방지
- MVCC로 읽기 일관성 보장
- 넥스트 키 락으로 Phantom Read 방지
- **MySQL 실무 표준**

### 5.4 SERIALIZABLE

**가장 높은 격리 수준**으로, 읽기 작업에도 공유 락을 획득합니다.

```sql
-- Transaction 1
START TRANSACTION;
SELECT * FROM users WHERE id = 1;  -- 공유 락(Shared Lock) 획득

-- Transaction 2
UPDATE users SET level = 'VIP' WHERE id = 1;  -- 대기 발생!
```

**특징:**
- 완벽한 격리성 보장
- 읽기에도 락 획득 → 심각한 성능 저하
- 동시성 거의 없음
- **실무에서 거의 사용 안 함**

### 5.5 격리 수준 비교표

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 | 실무 사용 |
|-----------|------------|---------------------|--------------|------|-----------|
| READ UNCOMMITTED | O | O | O | 최고 | X |
| READ COMMITTED | X | O | O | 높음 | △ (Oracle, PostgreSQL) |
| REPEATABLE READ | X | X | X | 보통 | O (MySQL 기본) |
| SERIALIZABLE | X | X | X | 최저 | X |

### 5.6 격리 수준 설정

```sql
-- 글로벌 설정 (서버 재시작 시 유지)
SET GLOBAL transaction_isolation = 'REPEATABLE-READ';

-- 세션 설정 (현재 커넥션만)
SET SESSION transaction_isolation = 'READ-COMMITTED';

-- 현재 설정 확인
SELECT @@transaction_isolation;
```

**권장:**
- MySQL: `REPEATABLE READ` (기본값 유지)
- 특별한 이유 없으면 변경 금지
- 애플리케이션 레벨에서 동시성 제어 우선 고려

---

## 6. 심화 학습 주제

### 6.1 MVCC (Multi-Version Concurrency Control)

**락 없이 일관된 읽기를 제공하는 핵심 메커니즘**입니다.

**동작 원리:**

```sql
-- users 테이블 현재 상태
id | name   | level   | TRX_ID (트랜잭션 ID)
1  | 홍길동  | NORMAL  | 100

-- Transaction 1 (TRX_ID: 200)
START TRANSACTION;
SELECT * FROM users WHERE id = 1;
-- 결과: name='홍길동', level='NORMAL'

-- Transaction 2 (TRX_ID: 201)
UPDATE users SET level = 'VIP' WHERE id = 1;
COMMIT;

-- 현재 테이블 상태 (최신 버전)
id | name   | level   | TRX_ID
1  | 홍길동  | VIP     | 201

-- Undo Log (이전 버전)
id | name   | level   | TRX_ID
1  | 홍길동  | NORMAL  | 100

-- Transaction 1 (TRX_ID: 200)
SELECT * FROM users WHERE id = 1;
-- 200 < 201 이므로 Undo Log에서 TRX_ID 100 버전 읽음
-- 결과: name='홍길동', level='NORMAL' (일관성 유지!)
```

**핵심 구성 요소:**

1. **Undo Log:**
   - 변경 전 데이터 백업 저장소
   - 롤백 및 MVCC 읽기에 사용
   - 트랜잭션 ID 기준으로 버전 관리

2. **트랜잭션 ID (TRX_ID):**
   - 각 트랜잭션에 부여되는 고유 번호
   - 순차적으로 증가
   - 읽기 시점 판단 기준

3. **Read View:**
   - 트랜잭션 시작 시점의 활성 트랜잭션 목록
   - 어떤 버전을 읽을지 결정

**장점:**
- **락 없는 읽기** → 읽기 성능 최대화
- **읽기-쓰기 충돌 없음** → 높은 동시성
- **트랜잭션 격리성 보장**

**주의사항:**
- 오래 실행되는 트랜잭션 → Undo Log 비대화
- Undo Log 정리 지연 → 디스크 공간 부족 위험

### 6.2 레플리케이션과 넥스트 키 락

**Binlog STATEMENT 형식의 데이터 정합성 보장**

**문제 상황:**

```sql
-- Master 서버
-- Transaction 1
DELETE FROM orders WHERE status = 'TEMP' AND created_at < '2023-01-01';

-- Binlog 기록 (STATEMENT 형식):
-- DELETE FROM orders WHERE status = 'TEMP' AND created_at < '2023-01-01';

-- 만약 갭 락이 없다면:
-- Transaction 2가 동시에 새 레코드 삽입 가능
-- INSERT INTO orders (status, created_at) VALUES ('TEMP', '2022-12-31');

-- Slave 서버에서 Binlog 재실행 시:
-- Master: 100건 삭제
-- Slave: 101건 삭제 (Transaction 2 레코드 포함)
-- → 데이터 불일치!
```

**넥스트 키 락의 해결:**

```sql
-- Master 서버
DELETE FROM orders WHERE status = 'TEMP' AND created_at < '2023-01-01';

-- 넥스트 키 락 발동:
-- 1. 조건 만족 레코드 잠금 (레코드 락)
-- 2. 레코드 사이 간격 잠금 (갭 락)
-- → 새 레코드 삽입 차단!

-- Transaction 2
INSERT INTO orders (status, created_at) VALUES ('TEMP', '2022-12-31');
-- 대기 발생! (갭 락에 막힘)

-- 결과:
-- Master와 Slave 모두 동일하게 100건 삭제 → 정합성 보장
```

**Binlog 형식별 차이:**

| Binlog 형식 | 넥스트 키 락 필요 | 장점 | 단점 |
|-------------|-------------------|------|------|
| STATEMENT | O (필수) | 로그 크기 작음 | 락 경합 많음, 일부 쿼리 재현 불가 |
| ROW | X (불필요) | 정확한 재현, 락 경합 적음 | 로그 크기 큼 |
| MIXED | 상황에 따라 | 자동 선택 | 예측 어려움 |

**권장 설정 (MySQL 8.0+):**

```sql
SET GLOBAL binlog_format = 'ROW';  -- 기본값
SET GLOBAL innodb_autoinc_lock_mode = 2;  -- 빠른 AUTO_INCREMENT
```

### 6.3 데드락 (Deadlock) 분석

**두 개 이상의 트랜잭션이 서로의 락을 기다리며 무한 대기하는 상황**입니다.

**전형적인 데드락 시나리오:**

```sql
-- Transaction 1
START TRANSACTION;
UPDATE users SET level = 'VIP' WHERE id = 1;  -- users.id=1 잠금

-- Transaction 2
START TRANSACTION;
UPDATE orders SET status = 'PAID' WHERE id = 100;  -- orders.id=100 잠금

-- Transaction 1
UPDATE orders SET status = 'PAID' WHERE id = 100;  -- 대기 (Trx2가 잠금 보유)

-- Transaction 2
UPDATE users SET level = 'VIP' WHERE id = 1;  -- 대기 (Trx1이 잠금 보유)

-- Deadlock 발생! InnoDB가 자동 감지하여 하나를 롤백
```

**데드락 확인:**

```sql
SHOW ENGINE INNODB STATUS\G

-- 출력 예시:
------------------------
LATEST DETECTED DEADLOCK
------------------------
2023-12-23 10:30:45 0x7f8b8c001700
*** (1) TRANSACTION:
TRANSACTION 12345, ACTIVE 10 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 10, OS thread handle 140241234567, query id 100 localhost root updating
UPDATE orders SET status = 'PAID' WHERE id = 100

*** (2) TRANSACTION:
TRANSACTION 12346, ACTIVE 8 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 11, OS thread handle 140241234568, query id 101 localhost root updating
UPDATE users SET level = 'VIP' WHERE id = 1

*** WE ROLL BACK TRANSACTION (2)
```

**데드락 최소화 전략:**

1. **트랜잭션 순서 통일:**

```java
// Bad: 트랜잭션마다 다른 순서
// Trx1: users → orders
// Trx2: orders → users

// Good: 모든 트랜잭션에서 동일한 순서
// 항상: users → orders
public void updateUserAndOrder(Long userId, Long orderId) {
    // 1. 먼저 users 잠금
    userRepository.updateLevel(userId, "VIP");

    // 2. 그 다음 orders 잠금
    orderRepository.updateStatus(orderId, "PAID");
}
```

2. **트랜잭션 크기 최소화:**

```java
// Bad: 긴 트랜잭션
@Transactional
public void processOrder(Order order) {
    // 10초 소요
    externalAPI.call();

    // DB 작업
    orderRepository.save(order);
}

// Good: 짧은 트랜잭션
public void processOrder(Order order) {
    externalAPI.call();  // 트랜잭션 밖

    saveOrder(order);  // 짧은 트랜잭션
}

@Transactional
private void saveOrder(Order order) {
    orderRepository.save(order);
}
```

3. **배치 크기 제한:**

```sql
-- Bad: 대량 UPDATE → 오래 잠금 유지
UPDATE orders SET status = 'EXPIRED' WHERE created_at < '2023-01-01';

-- Good: 작은 배치로 분할
UPDATE orders
SET status = 'EXPIRED'
WHERE created_at < '2023-01-01'
LIMIT 1000;  -- 여러 번 실행
```

### 6.4 외래키와 락 전파

**외래키는 부모 테이블에 공유 락을 자동으로 획득합니다.**

**잠금 전파 시나리오:**

```sql
CREATE TABLE departments (
    id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(id)
);

-- Transaction 1
START TRANSACTION;
INSERT INTO employees (id, name, dept_id) VALUES (1, '홍길동', 10);
-- employees 레코드 잠금 (배타 락)
-- departments.id=10 레코드에 공유 락 획득! (FK 체크)

-- Transaction 2
DELETE FROM departments WHERE id = 10;  -- 대기 발생!
-- 공유 락이 걸려 있어 배타 락 획득 불가
```

**데드락 위험:**

```sql
-- Transaction 1
START TRANSACTION;
INSERT INTO employees (id, name, dept_id) VALUES (1, '홍길동', 10);
-- departments.id=10 공유 락

-- Transaction 2
START TRANSACTION;
INSERT INTO employees (id, name, dept_id) VALUES (2, '김철수', 10);
-- departments.id=10 공유 락 (공유 락끼리는 호환)

-- Transaction 1
DELETE FROM departments WHERE id = 10;  -- 대기 (Trx2의 공유 락)

-- Transaction 2
DELETE FROM departments WHERE id = 10;  -- 대기 (Trx1의 공유 락)

-- Deadlock 발생!
```

**해결 방법:**

1. **외래키 제거 (애플리케이션 레벨 검증):**

```sql
-- FK 제거
ALTER TABLE employees DROP FOREIGN KEY fk_dept_id;

-- 애플리케이션에서 검증
if (!departmentRepository.existsById(deptId)) {
    throw new InvalidDepartmentException("존재하지 않는 부서입니다");
}
```

2. **트랜잭션 순서 통일:**

```java
// 항상 부모 → 자식 순서로 잠금
public void updateDepartmentAndEmployees(Long deptId) {
    // 1. 부모 먼저
    departmentRepository.update(deptId);

    // 2. 자식 나중
    employeeRepository.updateByDeptId(deptId);
}
```

### 6.5 낙관적 락 vs 비관적 락

**동시성 제어 전략의 두 가지 접근 방식**입니다.

#### 낙관적 락 (Optimistic Lock)

**충돌이 드물다고 가정하고, 커밋 시점에 충돌 감지**

```java
@Entity
public class Product {
    @Id
    private Long id;

    private String name;
    private Integer stock;

    @Version  // 낙관적 락
    private Long version;
}

// 사용 예시
public void decreaseStock(Long productId, int quantity) {
    Product product = productRepository.findById(productId)
        .orElseThrow();

    product.decreaseStock(quantity);

    productRepository.save(product);
    // UPDATE products
    // SET stock = ?, version = version + 1
    // WHERE id = ? AND version = ?

    // 만약 다른 트랜잭션이 먼저 수정했다면:
    // version이 달라서 UPDATE 0건 → OptimisticLockException 발생
}
```

**장점:**
- 락을 획득하지 않음 → 성능 좋음
- 데드락 없음
- 읽기 비용 낮음

**단점:**
- 충돌 시 재시도 필요 (애플리케이션 구현)
- 충돌이 잦으면 성능 저하

**적합한 경우:**
- 읽기가 많고 쓰기가 적은 경우
- 충돌 확률이 낮은 경우
- 상품 조회, 게시글 조회수 등

#### 비관적 락 (Pessimistic Lock)

**충돌이 자주 발생한다고 가정하고, 미리 락 획득**

```java
public interface ProductRepository extends JpaRepository<Product, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") Long id);
}

// 사용 예시
@Transactional
public void decreaseStock(Long productId, int quantity) {
    Product product = productRepository.findByIdWithLock(productId)
        .orElseThrow();
    // SELECT ... FOR UPDATE
    // 레코드 잠금 획득 (다른 트랜잭션 대기)

    product.decreaseStock(quantity);
    // 트랜잭션 종료 시 자동 커밋 및 락 해제
}
```

**장점:**
- 충돌 방지 확실
- 재시도 로직 불필요
- 데이터 정합성 보장

**단점:**
- 락 대기 시간 발생 → 성능 저하
- 데드락 위험
- 동시성 낮음

**적합한 경우:**
- 충돌이 자주 발생하는 경우
- 재고 감소, 좌석 예약, 포인트 차감 등
- 절대 충돌 안 되는 중요 작업

#### 비교표

| 구분 | 낙관적 락 | 비관적 락 |
|------|-----------|-----------|
| 구현 방식 | @Version | SELECT FOR UPDATE |
| 락 획득 시점 | 커밋 시점 | 조회 시점 |
| 충돌 처리 | 예외 발생 (재시도) | 대기 |
| 성능 | 높음 (충돌 적을 때) | 낮음 (대기 시간) |
| 데드락 | 없음 | 있음 |
| 적합한 경우 | 읽기 많음 | 쓰기 많음, 충돌 빈번 |

**실무 선택 기준:**

```java
// 낙관적 락: 조회수 증가 (충돌 OK, 재시도 가능)
@Version
private Long version;

public void increaseViewCount() {
    try {
        post.increaseViewCount();
        postRepository.save(post);
    } catch (OptimisticLockException e) {
        // 재시도 또는 무시
    }
}

// 비관적 락: 재고 감소 (충돌 불가, 정확성 필수)
@Lock(LockModeType.PESSIMISTIC_WRITE)
Product findByIdWithLock(Long id);

public void decreaseStock() {
    Product product = productRepository.findByIdWithLock(id);
    product.decreaseStock(quantity);  // 락 보유 중 → 안전
}
```

---

## 정리

### 핵심 원칙

1. **트랜잭션 범위는 최소화하라**
   - 외부 API, 이메일, 파일 처리는 트랜잭션 밖으로
   - DB 작업만 트랜잭션으로 묶기

2. **InnoDB는 인덱스를 잠근다**
   - UPDATE/DELETE 시 반드시 인덱스 확인
   - EXPLAIN으로 실행 계획 검증

3. **REPEATABLE READ를 이해하라**
   - MySQL InnoDB 기본 격리 수준
   - MVCC와 넥스트 키 락으로 일관성 보장

4. **데드락을 최소화하라**
   - 트랜잭션 순서 통일
   - 트랜잭션 크기 최소화
   - 외래키 사용 신중히 검토

5. **동시성 제어 전략을 선택하라**
   - 충돌 적음 → 낙관적 락
   - 충돌 많음 → 비관적 락