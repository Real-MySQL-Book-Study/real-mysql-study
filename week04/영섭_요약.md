# Week 04 정리

## 복합 인덱스 (Multi-Column Index)

복합 인덱스는 두 개 이상의 컬럼을 결합해서 만든 인덱스

**핵심 특징:**

- 인덱스 컬럼의 순서가 매우 중요. `INDEX(col1, col2, col3)`로 생성하면 col1 → col2 → col3 순서로 정렬
- 왼쪽 컬럼부터 순서대로 사용해야 인덱스가 효율적으로 작동함. 예를 들어 `INDEX(A, B, C)`인 경우, A만 사용하거나 A+B를 사용하거나 A+B+C를 사용하는 쿼리는 인덱스를 타지만, B만 사용하거나 C만 사용하는 경우는 인덱스를 제대로 활용하지 못함
- 첫 번째 컬럼의 카디널리티(중복도)가 높을수록 효율적

## 인덱스 스캔 방식

**인덱스 레인지 스캔 (Index Range Scan):** 인덱스의 특정 범위만 읽는 방식으로, 가장 빠르고 효율적. WHERE 조건에 인덱스 컬럼이 사용되고 범위 조건(>, <, BETWEEN 등)일 때 사용

**인덱스 풀 스캔 (Index Full Scan):** 인덱스 전체를 처음부터 끝까지 읽는 방식. 테이블 풀 스캔보다는 빠르지만, 레인지 스캔보다는 느립니다. 쿼리가 인덱스 컬럼만으로 처리 가능하거나 인덱스로 정렬이 되어 있을 때 사용

**루스 인덱스 스캔 (Loose Index Scan):** 인덱스를 듬성듬성 읽는 방식으로, GROUP BY나 집계 함수 최적화에 사용. 불필요한 레코드를 건너뛰면서 필요한 부분만 읽음

**인덱스 스킵 스캔 (Index Skip Scan):** MySQL 8.0에서 추가된 기능으로, 복합 인덱스에서 첫 번째 컬럼의 조건이 없어도 두 번째 컬럼으로 검색 가능. 단, 첫 번째 컬럼의 유니크한 값이 적을 때만 효율적

## 커버링 인덱스 (Covering Index)

커버링 인덱스는 쿼리를 처리하는 데 필요한 모든 컬럼을 인덱스가 포함하고 있어서, 실제 테이블 데이터에 접근하지 않고 인덱스만으로 쿼리를 처리할 수 있는 경우를 말합니다.

**장점:**

- 테이블 랜덤 액세스가 발생하지 않아 매우 빠릅니다.
- 디스크 I/O가 크게 줄어듭니다.
- EXPLAIN 결과에서 Extra 컬럼에 "Using index"로 표시됩니다.

**예시:**

```sql
-- INDEX(dept_no, emp_no)가 있을 때
SELECT dept_no, emp_no
FROM dept_emp
WHERE dept_no = 'd005';
-- 이 쿼리는 인덱스만으로 처리 가능 (커버링 인덱스)
```

InnoDB의 모든 세컨더리 인덱스는 자동으로 프라이머리 키를 포함하므로, 프라이머리 키까지 SELECT하는 경우에도 커버링 인덱스가 될 수 있습니다.

인덱스 스캔 방식을 실무에 적용할 수 있는 사례들을 알려드리겠습니다.

## 실무 적용 사례

**1. 인덱스 레인지 스캔 - 날짜 범위 조회**

```sql
-- 주문 테이블에서 특정 기간의 주문 조회
SELECT * FROM orders
WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31'
  AND status = 'COMPLETED';

-- INDEX(order_date, status) 생성 시 효율적인 레인지 스캔 발생
```

실무에서 가장 흔한 케이스. 일별/월별 매출 집계, 로그 분석 등에서 날짜 범위 조건은 필수적이고, 이때 적절한 인덱스가 있으면 레인지 스캔으로 빠르게 처리 가능

**2. 루스 인덱스 스캔 - 카테고리별 최신 상품**

```sql
-- 각 카테고리별 최신 상품 1개씩 조회
SELECT category_id, MAX(created_at)
FROM products
GROUP BY category_id;

-- INDEX(category_id, created_at) 있으면 루스 스캔 발생
-- 각 카테고리의 마지막 레코드만 읽고 건너뛰므로 매우 빠름
```

대시보드에서 "카테고리별 최신 상품", "사용자별 마지막 로그인 시간" 같은 집계 쿼리에서 루스 스캔이 자동으로 적용되면 성능이 크게 향상

**3. 인덱스 스킵 스캔 - 성별 없이 나이로 검색**

```sql
-- INDEX(gender, age)가 있는데 성별 조건 없이 나이만 검색
SELECT * FROM users
WHERE age BETWEEN 20 AND 30;

-- MySQL 8.0에서는 스킵 스캔으로 처리 가능
-- gender가 'M', 'F' 2개뿐이라면 효율적
```

레거시 시스템에서 복합 인덱스 첫 컬럼을 변경하기 어려울 때 유용합니다. 하지만 첫 번째 컬럼의 카디널리티가 낮을 때만 효과적이므로, 실무에서는 EXPLAIN으로 확인 후 적용해야 합니다.

**4. 커버링 인덱스 - 페이징 최적화**

```sql
-- 게시판 목록 조회 (커버링 인덱스 미적용)
SELECT * FROM posts
WHERE category = 'notice'
ORDER BY created_at DESC
LIMIT 20 OFFSET 1000;
-- 테이블 접근 필요, 느림

-- 커버링 인덱스 적용
SELECT p.* FROM posts p
INNER JOIN (
  SELECT id FROM posts
  WHERE category = 'notice'
  ORDER BY created_at DESC
  LIMIT 20 OFFSET 1000
) sub ON p.id = sub.id;

-- INDEX(category, created_at, id)로 서브쿼리를 커버링
-- id만 먼저 빠르게 찾고 조인, 큰 OFFSET에서 효과적
```

게시판, 상품 목록 등 페이징 쿼리에서 OFFSET이 클수록 성능이 떨어지는 문제를 커버링 인덱스로 해결할 수 있습니다.

**5. 인덱스 풀 스캔 활용 - 정렬 최적화**

```sql
-- 전체 회원을 가입일순 정렬
SELECT user_id, name, created_at
FROM users
ORDER BY created_at;

-- INDEX(created_at, user_id, name) 생성
-- WHERE 없지만 인덱스가 이미 정렬되어 있어
-- 인덱스 풀 스캔 + Using index로 빠르게 처리
```

통계나 배치 작업에서 대량 데이터를 정렬할 때, 인덱스 풀 스캔을 활용하면 별도 정렬 작업(filesort) 없이 처리됩니다.

**실무 팁:**

- EXPLAIN으로 어떤 스캔 방식이 사용되는지 항상 확인
- 커버링 인덱스는 SELECT 컬럼을 줄이는 것만으로도 적용 가능
- 스킵 스캔은 옵티마이저가 자동 선택하지만, 때로는 인덱스 힌트가 필요
- 인덱스가 많으면 INSERT/UPDATE 성능이 떨어지므로, 실제 쿼리 패턴을 분석해서 필요한 것만 생성
